// Code generated by http://github.com/gojuno/minimock (v3.4.0). DO NOT EDIT.

package mock

//go:generate minimock -i github.com/vlad1028/order-manager/internal/order.Repository -o order_repository_mock.go -n OrderRepositoryMock -p mock

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/vlad1028/order-manager/internal/models/basetypes"
	"github.com/vlad1028/order-manager/internal/models/order"
)

// OrderRepositoryMock implements mm_order.Repository
type OrderRepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcAddOrUpdate          func(ctx context.Context, op1 *order.Order) (exists bool, err error)
	funcAddOrUpdateOrigin    string
	inspectFuncAddOrUpdate   func(ctx context.Context, op1 *order.Order)
	afterAddOrUpdateCounter  uint64
	beforeAddOrUpdateCounter uint64
	AddOrUpdateMock          mOrderRepositoryMockAddOrUpdate

	funcAddOrUpdateList          func(ctx context.Context, opa1 []*order.Order) (err error)
	funcAddOrUpdateListOrigin    string
	inspectFuncAddOrUpdateList   func(ctx context.Context, opa1 []*order.Order)
	afterAddOrUpdateListCounter  uint64
	beforeAddOrUpdateListCounter uint64
	AddOrUpdateListMock          mOrderRepositoryMockAddOrUpdateList

	funcDelete          func(ctx context.Context, i1 basetypes.ID) (err error)
	funcDeleteOrigin    string
	inspectFuncDelete   func(ctx context.Context, i1 basetypes.ID)
	afterDeleteCounter  uint64
	beforeDeleteCounter uint64
	DeleteMock          mOrderRepositoryMockDelete

	funcDeleteBy          func(ctx context.Context, fp1 *order.Filter) (err error)
	funcDeleteByOrigin    string
	inspectFuncDeleteBy   func(ctx context.Context, fp1 *order.Filter)
	afterDeleteByCounter  uint64
	beforeDeleteByCounter uint64
	DeleteByMock          mOrderRepositoryMockDeleteBy

	funcGet          func(ctx context.Context, i1 basetypes.ID) (op1 *order.Order, err error)
	funcGetOrigin    string
	inspectFuncGet   func(ctx context.Context, i1 basetypes.ID)
	afterGetCounter  uint64
	beforeGetCounter uint64
	GetMock          mOrderRepositoryMockGet

	funcGetBy          func(ctx context.Context, fp1 *order.Filter) (opa1 []*order.Order, err error)
	funcGetByOrigin    string
	inspectFuncGetBy   func(ctx context.Context, fp1 *order.Filter)
	afterGetByCounter  uint64
	beforeGetByCounter uint64
	GetByMock          mOrderRepositoryMockGetBy

	funcGetByPaginated          func(ctx context.Context, filter *order.Filter, offset uint, limit int) (opa1 []*order.Order, err error)
	funcGetByPaginatedOrigin    string
	inspectFuncGetByPaginated   func(ctx context.Context, filter *order.Filter, offset uint, limit int)
	afterGetByPaginatedCounter  uint64
	beforeGetByPaginatedCounter uint64
	GetByPaginatedMock          mOrderRepositoryMockGetByPaginated
}

// NewOrderRepositoryMock returns a mock for mm_order.Repository
func NewOrderRepositoryMock(t minimock.Tester) *OrderRepositoryMock {
	m := &OrderRepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddOrUpdateMock = mOrderRepositoryMockAddOrUpdate{mock: m}
	m.AddOrUpdateMock.callArgs = []*OrderRepositoryMockAddOrUpdateParams{}

	m.AddOrUpdateListMock = mOrderRepositoryMockAddOrUpdateList{mock: m}
	m.AddOrUpdateListMock.callArgs = []*OrderRepositoryMockAddOrUpdateListParams{}

	m.DeleteMock = mOrderRepositoryMockDelete{mock: m}
	m.DeleteMock.callArgs = []*OrderRepositoryMockDeleteParams{}

	m.DeleteByMock = mOrderRepositoryMockDeleteBy{mock: m}
	m.DeleteByMock.callArgs = []*OrderRepositoryMockDeleteByParams{}

	m.GetMock = mOrderRepositoryMockGet{mock: m}
	m.GetMock.callArgs = []*OrderRepositoryMockGetParams{}

	m.GetByMock = mOrderRepositoryMockGetBy{mock: m}
	m.GetByMock.callArgs = []*OrderRepositoryMockGetByParams{}

	m.GetByPaginatedMock = mOrderRepositoryMockGetByPaginated{mock: m}
	m.GetByPaginatedMock.callArgs = []*OrderRepositoryMockGetByPaginatedParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mOrderRepositoryMockAddOrUpdate struct {
	optional           bool
	mock               *OrderRepositoryMock
	defaultExpectation *OrderRepositoryMockAddOrUpdateExpectation
	expectations       []*OrderRepositoryMockAddOrUpdateExpectation

	callArgs []*OrderRepositoryMockAddOrUpdateParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// OrderRepositoryMockAddOrUpdateExpectation specifies expectation struct of the Repository.AddOrUpdate
type OrderRepositoryMockAddOrUpdateExpectation struct {
	mock               *OrderRepositoryMock
	params             *OrderRepositoryMockAddOrUpdateParams
	paramPtrs          *OrderRepositoryMockAddOrUpdateParamPtrs
	expectationOrigins OrderRepositoryMockAddOrUpdateExpectationOrigins
	results            *OrderRepositoryMockAddOrUpdateResults
	returnOrigin       string
	Counter            uint64
}

// OrderRepositoryMockAddOrUpdateParams contains parameters of the Repository.AddOrUpdate
type OrderRepositoryMockAddOrUpdateParams struct {
	ctx context.Context
	op1 *order.Order
}

// OrderRepositoryMockAddOrUpdateParamPtrs contains pointers to parameters of the Repository.AddOrUpdate
type OrderRepositoryMockAddOrUpdateParamPtrs struct {
	ctx *context.Context
	op1 **order.Order
}

// OrderRepositoryMockAddOrUpdateResults contains results of the Repository.AddOrUpdate
type OrderRepositoryMockAddOrUpdateResults struct {
	exists bool
	err    error
}

// OrderRepositoryMockAddOrUpdateOrigins contains origins of expectations of the Repository.AddOrUpdate
type OrderRepositoryMockAddOrUpdateExpectationOrigins struct {
	origin    string
	originCtx string
	originOp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAddOrUpdate *mOrderRepositoryMockAddOrUpdate) Optional() *mOrderRepositoryMockAddOrUpdate {
	mmAddOrUpdate.optional = true
	return mmAddOrUpdate
}

// Expect sets up expected params for Repository.AddOrUpdate
func (mmAddOrUpdate *mOrderRepositoryMockAddOrUpdate) Expect(ctx context.Context, op1 *order.Order) *mOrderRepositoryMockAddOrUpdate {
	if mmAddOrUpdate.mock.funcAddOrUpdate != nil {
		mmAddOrUpdate.mock.t.Fatalf("OrderRepositoryMock.AddOrUpdate mock is already set by Set")
	}

	if mmAddOrUpdate.defaultExpectation == nil {
		mmAddOrUpdate.defaultExpectation = &OrderRepositoryMockAddOrUpdateExpectation{}
	}

	if mmAddOrUpdate.defaultExpectation.paramPtrs != nil {
		mmAddOrUpdate.mock.t.Fatalf("OrderRepositoryMock.AddOrUpdate mock is already set by ExpectParams functions")
	}

	mmAddOrUpdate.defaultExpectation.params = &OrderRepositoryMockAddOrUpdateParams{ctx, op1}
	mmAddOrUpdate.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmAddOrUpdate.expectations {
		if minimock.Equal(e.params, mmAddOrUpdate.defaultExpectation.params) {
			mmAddOrUpdate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddOrUpdate.defaultExpectation.params)
		}
	}

	return mmAddOrUpdate
}

// ExpectCtxParam1 sets up expected param ctx for Repository.AddOrUpdate
func (mmAddOrUpdate *mOrderRepositoryMockAddOrUpdate) ExpectCtxParam1(ctx context.Context) *mOrderRepositoryMockAddOrUpdate {
	if mmAddOrUpdate.mock.funcAddOrUpdate != nil {
		mmAddOrUpdate.mock.t.Fatalf("OrderRepositoryMock.AddOrUpdate mock is already set by Set")
	}

	if mmAddOrUpdate.defaultExpectation == nil {
		mmAddOrUpdate.defaultExpectation = &OrderRepositoryMockAddOrUpdateExpectation{}
	}

	if mmAddOrUpdate.defaultExpectation.params != nil {
		mmAddOrUpdate.mock.t.Fatalf("OrderRepositoryMock.AddOrUpdate mock is already set by Expect")
	}

	if mmAddOrUpdate.defaultExpectation.paramPtrs == nil {
		mmAddOrUpdate.defaultExpectation.paramPtrs = &OrderRepositoryMockAddOrUpdateParamPtrs{}
	}
	mmAddOrUpdate.defaultExpectation.paramPtrs.ctx = &ctx
	mmAddOrUpdate.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmAddOrUpdate
}

// ExpectOp1Param2 sets up expected param op1 for Repository.AddOrUpdate
func (mmAddOrUpdate *mOrderRepositoryMockAddOrUpdate) ExpectOp1Param2(op1 *order.Order) *mOrderRepositoryMockAddOrUpdate {
	if mmAddOrUpdate.mock.funcAddOrUpdate != nil {
		mmAddOrUpdate.mock.t.Fatalf("OrderRepositoryMock.AddOrUpdate mock is already set by Set")
	}

	if mmAddOrUpdate.defaultExpectation == nil {
		mmAddOrUpdate.defaultExpectation = &OrderRepositoryMockAddOrUpdateExpectation{}
	}

	if mmAddOrUpdate.defaultExpectation.params != nil {
		mmAddOrUpdate.mock.t.Fatalf("OrderRepositoryMock.AddOrUpdate mock is already set by Expect")
	}

	if mmAddOrUpdate.defaultExpectation.paramPtrs == nil {
		mmAddOrUpdate.defaultExpectation.paramPtrs = &OrderRepositoryMockAddOrUpdateParamPtrs{}
	}
	mmAddOrUpdate.defaultExpectation.paramPtrs.op1 = &op1
	mmAddOrUpdate.defaultExpectation.expectationOrigins.originOp1 = minimock.CallerInfo(1)

	return mmAddOrUpdate
}

// Inspect accepts an inspector function that has same arguments as the Repository.AddOrUpdate
func (mmAddOrUpdate *mOrderRepositoryMockAddOrUpdate) Inspect(f func(ctx context.Context, op1 *order.Order)) *mOrderRepositoryMockAddOrUpdate {
	if mmAddOrUpdate.mock.inspectFuncAddOrUpdate != nil {
		mmAddOrUpdate.mock.t.Fatalf("Inspect function is already set for OrderRepositoryMock.AddOrUpdate")
	}

	mmAddOrUpdate.mock.inspectFuncAddOrUpdate = f

	return mmAddOrUpdate
}

// Return sets up results that will be returned by Repository.AddOrUpdate
func (mmAddOrUpdate *mOrderRepositoryMockAddOrUpdate) Return(exists bool, err error) *OrderRepositoryMock {
	if mmAddOrUpdate.mock.funcAddOrUpdate != nil {
		mmAddOrUpdate.mock.t.Fatalf("OrderRepositoryMock.AddOrUpdate mock is already set by Set")
	}

	if mmAddOrUpdate.defaultExpectation == nil {
		mmAddOrUpdate.defaultExpectation = &OrderRepositoryMockAddOrUpdateExpectation{mock: mmAddOrUpdate.mock}
	}
	mmAddOrUpdate.defaultExpectation.results = &OrderRepositoryMockAddOrUpdateResults{exists, err}
	mmAddOrUpdate.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmAddOrUpdate.mock
}

// Set uses given function f to mock the Repository.AddOrUpdate method
func (mmAddOrUpdate *mOrderRepositoryMockAddOrUpdate) Set(f func(ctx context.Context, op1 *order.Order) (exists bool, err error)) *OrderRepositoryMock {
	if mmAddOrUpdate.defaultExpectation != nil {
		mmAddOrUpdate.mock.t.Fatalf("Default expectation is already set for the Repository.AddOrUpdate method")
	}

	if len(mmAddOrUpdate.expectations) > 0 {
		mmAddOrUpdate.mock.t.Fatalf("Some expectations are already set for the Repository.AddOrUpdate method")
	}

	mmAddOrUpdate.mock.funcAddOrUpdate = f
	mmAddOrUpdate.mock.funcAddOrUpdateOrigin = minimock.CallerInfo(1)
	return mmAddOrUpdate.mock
}

// When sets expectation for the Repository.AddOrUpdate which will trigger the result defined by the following
// Then helper
func (mmAddOrUpdate *mOrderRepositoryMockAddOrUpdate) When(ctx context.Context, op1 *order.Order) *OrderRepositoryMockAddOrUpdateExpectation {
	if mmAddOrUpdate.mock.funcAddOrUpdate != nil {
		mmAddOrUpdate.mock.t.Fatalf("OrderRepositoryMock.AddOrUpdate mock is already set by Set")
	}

	expectation := &OrderRepositoryMockAddOrUpdateExpectation{
		mock:               mmAddOrUpdate.mock,
		params:             &OrderRepositoryMockAddOrUpdateParams{ctx, op1},
		expectationOrigins: OrderRepositoryMockAddOrUpdateExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmAddOrUpdate.expectations = append(mmAddOrUpdate.expectations, expectation)
	return expectation
}

// Then sets up Repository.AddOrUpdate return parameters for the expectation previously defined by the When method
func (e *OrderRepositoryMockAddOrUpdateExpectation) Then(exists bool, err error) *OrderRepositoryMock {
	e.results = &OrderRepositoryMockAddOrUpdateResults{exists, err}
	return e.mock
}

// Times sets number of times Repository.AddOrUpdate should be invoked
func (mmAddOrUpdate *mOrderRepositoryMockAddOrUpdate) Times(n uint64) *mOrderRepositoryMockAddOrUpdate {
	if n == 0 {
		mmAddOrUpdate.mock.t.Fatalf("Times of OrderRepositoryMock.AddOrUpdate mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAddOrUpdate.expectedInvocations, n)
	mmAddOrUpdate.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmAddOrUpdate
}

func (mmAddOrUpdate *mOrderRepositoryMockAddOrUpdate) invocationsDone() bool {
	if len(mmAddOrUpdate.expectations) == 0 && mmAddOrUpdate.defaultExpectation == nil && mmAddOrUpdate.mock.funcAddOrUpdate == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAddOrUpdate.mock.afterAddOrUpdateCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAddOrUpdate.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AddOrUpdate implements mm_order.Repository
func (mmAddOrUpdate *OrderRepositoryMock) AddOrUpdate(ctx context.Context, op1 *order.Order) (exists bool, err error) {
	mm_atomic.AddUint64(&mmAddOrUpdate.beforeAddOrUpdateCounter, 1)
	defer mm_atomic.AddUint64(&mmAddOrUpdate.afterAddOrUpdateCounter, 1)

	mmAddOrUpdate.t.Helper()

	if mmAddOrUpdate.inspectFuncAddOrUpdate != nil {
		mmAddOrUpdate.inspectFuncAddOrUpdate(ctx, op1)
	}

	mm_params := OrderRepositoryMockAddOrUpdateParams{ctx, op1}

	// Record call args
	mmAddOrUpdate.AddOrUpdateMock.mutex.Lock()
	mmAddOrUpdate.AddOrUpdateMock.callArgs = append(mmAddOrUpdate.AddOrUpdateMock.callArgs, &mm_params)
	mmAddOrUpdate.AddOrUpdateMock.mutex.Unlock()

	for _, e := range mmAddOrUpdate.AddOrUpdateMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.exists, e.results.err
		}
	}

	if mmAddOrUpdate.AddOrUpdateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddOrUpdate.AddOrUpdateMock.defaultExpectation.Counter, 1)
		mm_want := mmAddOrUpdate.AddOrUpdateMock.defaultExpectation.params
		mm_want_ptrs := mmAddOrUpdate.AddOrUpdateMock.defaultExpectation.paramPtrs

		mm_got := OrderRepositoryMockAddOrUpdateParams{ctx, op1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmAddOrUpdate.t.Errorf("OrderRepositoryMock.AddOrUpdate got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddOrUpdate.AddOrUpdateMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.op1 != nil && !minimock.Equal(*mm_want_ptrs.op1, mm_got.op1) {
				mmAddOrUpdate.t.Errorf("OrderRepositoryMock.AddOrUpdate got unexpected parameter op1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddOrUpdate.AddOrUpdateMock.defaultExpectation.expectationOrigins.originOp1, *mm_want_ptrs.op1, mm_got.op1, minimock.Diff(*mm_want_ptrs.op1, mm_got.op1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddOrUpdate.t.Errorf("OrderRepositoryMock.AddOrUpdate got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmAddOrUpdate.AddOrUpdateMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddOrUpdate.AddOrUpdateMock.defaultExpectation.results
		if mm_results == nil {
			mmAddOrUpdate.t.Fatal("No results are set for the OrderRepositoryMock.AddOrUpdate")
		}
		return (*mm_results).exists, (*mm_results).err
	}
	if mmAddOrUpdate.funcAddOrUpdate != nil {
		return mmAddOrUpdate.funcAddOrUpdate(ctx, op1)
	}
	mmAddOrUpdate.t.Fatalf("Unexpected call to OrderRepositoryMock.AddOrUpdate. %v %v", ctx, op1)
	return
}

// AddOrUpdateAfterCounter returns a count of finished OrderRepositoryMock.AddOrUpdate invocations
func (mmAddOrUpdate *OrderRepositoryMock) AddOrUpdateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddOrUpdate.afterAddOrUpdateCounter)
}

// AddOrUpdateBeforeCounter returns a count of OrderRepositoryMock.AddOrUpdate invocations
func (mmAddOrUpdate *OrderRepositoryMock) AddOrUpdateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddOrUpdate.beforeAddOrUpdateCounter)
}

// Calls returns a list of arguments used in each call to OrderRepositoryMock.AddOrUpdate.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddOrUpdate *mOrderRepositoryMockAddOrUpdate) Calls() []*OrderRepositoryMockAddOrUpdateParams {
	mmAddOrUpdate.mutex.RLock()

	argCopy := make([]*OrderRepositoryMockAddOrUpdateParams, len(mmAddOrUpdate.callArgs))
	copy(argCopy, mmAddOrUpdate.callArgs)

	mmAddOrUpdate.mutex.RUnlock()

	return argCopy
}

// MinimockAddOrUpdateDone returns true if the count of the AddOrUpdate invocations corresponds
// the number of defined expectations
func (m *OrderRepositoryMock) MinimockAddOrUpdateDone() bool {
	if m.AddOrUpdateMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AddOrUpdateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AddOrUpdateMock.invocationsDone()
}

// MinimockAddOrUpdateInspect logs each unmet expectation
func (m *OrderRepositoryMock) MinimockAddOrUpdateInspect() {
	for _, e := range m.AddOrUpdateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OrderRepositoryMock.AddOrUpdate at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterAddOrUpdateCounter := mm_atomic.LoadUint64(&m.afterAddOrUpdateCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AddOrUpdateMock.defaultExpectation != nil && afterAddOrUpdateCounter < 1 {
		if m.AddOrUpdateMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to OrderRepositoryMock.AddOrUpdate at\n%s", m.AddOrUpdateMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to OrderRepositoryMock.AddOrUpdate at\n%s with params: %#v", m.AddOrUpdateMock.defaultExpectation.expectationOrigins.origin, *m.AddOrUpdateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddOrUpdate != nil && afterAddOrUpdateCounter < 1 {
		m.t.Errorf("Expected call to OrderRepositoryMock.AddOrUpdate at\n%s", m.funcAddOrUpdateOrigin)
	}

	if !m.AddOrUpdateMock.invocationsDone() && afterAddOrUpdateCounter > 0 {
		m.t.Errorf("Expected %d calls to OrderRepositoryMock.AddOrUpdate at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.AddOrUpdateMock.expectedInvocations), m.AddOrUpdateMock.expectedInvocationsOrigin, afterAddOrUpdateCounter)
	}
}

type mOrderRepositoryMockAddOrUpdateList struct {
	optional           bool
	mock               *OrderRepositoryMock
	defaultExpectation *OrderRepositoryMockAddOrUpdateListExpectation
	expectations       []*OrderRepositoryMockAddOrUpdateListExpectation

	callArgs []*OrderRepositoryMockAddOrUpdateListParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// OrderRepositoryMockAddOrUpdateListExpectation specifies expectation struct of the Repository.AddOrUpdateList
type OrderRepositoryMockAddOrUpdateListExpectation struct {
	mock               *OrderRepositoryMock
	params             *OrderRepositoryMockAddOrUpdateListParams
	paramPtrs          *OrderRepositoryMockAddOrUpdateListParamPtrs
	expectationOrigins OrderRepositoryMockAddOrUpdateListExpectationOrigins
	results            *OrderRepositoryMockAddOrUpdateListResults
	returnOrigin       string
	Counter            uint64
}

// OrderRepositoryMockAddOrUpdateListParams contains parameters of the Repository.AddOrUpdateList
type OrderRepositoryMockAddOrUpdateListParams struct {
	ctx  context.Context
	opa1 []*order.Order
}

// OrderRepositoryMockAddOrUpdateListParamPtrs contains pointers to parameters of the Repository.AddOrUpdateList
type OrderRepositoryMockAddOrUpdateListParamPtrs struct {
	ctx  *context.Context
	opa1 *[]*order.Order
}

// OrderRepositoryMockAddOrUpdateListResults contains results of the Repository.AddOrUpdateList
type OrderRepositoryMockAddOrUpdateListResults struct {
	err error
}

// OrderRepositoryMockAddOrUpdateListOrigins contains origins of expectations of the Repository.AddOrUpdateList
type OrderRepositoryMockAddOrUpdateListExpectationOrigins struct {
	origin     string
	originCtx  string
	originOpa1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAddOrUpdateList *mOrderRepositoryMockAddOrUpdateList) Optional() *mOrderRepositoryMockAddOrUpdateList {
	mmAddOrUpdateList.optional = true
	return mmAddOrUpdateList
}

// Expect sets up expected params for Repository.AddOrUpdateList
func (mmAddOrUpdateList *mOrderRepositoryMockAddOrUpdateList) Expect(ctx context.Context, opa1 []*order.Order) *mOrderRepositoryMockAddOrUpdateList {
	if mmAddOrUpdateList.mock.funcAddOrUpdateList != nil {
		mmAddOrUpdateList.mock.t.Fatalf("OrderRepositoryMock.AddOrUpdateList mock is already set by Set")
	}

	if mmAddOrUpdateList.defaultExpectation == nil {
		mmAddOrUpdateList.defaultExpectation = &OrderRepositoryMockAddOrUpdateListExpectation{}
	}

	if mmAddOrUpdateList.defaultExpectation.paramPtrs != nil {
		mmAddOrUpdateList.mock.t.Fatalf("OrderRepositoryMock.AddOrUpdateList mock is already set by ExpectParams functions")
	}

	mmAddOrUpdateList.defaultExpectation.params = &OrderRepositoryMockAddOrUpdateListParams{ctx, opa1}
	mmAddOrUpdateList.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmAddOrUpdateList.expectations {
		if minimock.Equal(e.params, mmAddOrUpdateList.defaultExpectation.params) {
			mmAddOrUpdateList.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddOrUpdateList.defaultExpectation.params)
		}
	}

	return mmAddOrUpdateList
}

// ExpectCtxParam1 sets up expected param ctx for Repository.AddOrUpdateList
func (mmAddOrUpdateList *mOrderRepositoryMockAddOrUpdateList) ExpectCtxParam1(ctx context.Context) *mOrderRepositoryMockAddOrUpdateList {
	if mmAddOrUpdateList.mock.funcAddOrUpdateList != nil {
		mmAddOrUpdateList.mock.t.Fatalf("OrderRepositoryMock.AddOrUpdateList mock is already set by Set")
	}

	if mmAddOrUpdateList.defaultExpectation == nil {
		mmAddOrUpdateList.defaultExpectation = &OrderRepositoryMockAddOrUpdateListExpectation{}
	}

	if mmAddOrUpdateList.defaultExpectation.params != nil {
		mmAddOrUpdateList.mock.t.Fatalf("OrderRepositoryMock.AddOrUpdateList mock is already set by Expect")
	}

	if mmAddOrUpdateList.defaultExpectation.paramPtrs == nil {
		mmAddOrUpdateList.defaultExpectation.paramPtrs = &OrderRepositoryMockAddOrUpdateListParamPtrs{}
	}
	mmAddOrUpdateList.defaultExpectation.paramPtrs.ctx = &ctx
	mmAddOrUpdateList.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmAddOrUpdateList
}

// ExpectOpa1Param2 sets up expected param opa1 for Repository.AddOrUpdateList
func (mmAddOrUpdateList *mOrderRepositoryMockAddOrUpdateList) ExpectOpa1Param2(opa1 []*order.Order) *mOrderRepositoryMockAddOrUpdateList {
	if mmAddOrUpdateList.mock.funcAddOrUpdateList != nil {
		mmAddOrUpdateList.mock.t.Fatalf("OrderRepositoryMock.AddOrUpdateList mock is already set by Set")
	}

	if mmAddOrUpdateList.defaultExpectation == nil {
		mmAddOrUpdateList.defaultExpectation = &OrderRepositoryMockAddOrUpdateListExpectation{}
	}

	if mmAddOrUpdateList.defaultExpectation.params != nil {
		mmAddOrUpdateList.mock.t.Fatalf("OrderRepositoryMock.AddOrUpdateList mock is already set by Expect")
	}

	if mmAddOrUpdateList.defaultExpectation.paramPtrs == nil {
		mmAddOrUpdateList.defaultExpectation.paramPtrs = &OrderRepositoryMockAddOrUpdateListParamPtrs{}
	}
	mmAddOrUpdateList.defaultExpectation.paramPtrs.opa1 = &opa1
	mmAddOrUpdateList.defaultExpectation.expectationOrigins.originOpa1 = minimock.CallerInfo(1)

	return mmAddOrUpdateList
}

// Inspect accepts an inspector function that has same arguments as the Repository.AddOrUpdateList
func (mmAddOrUpdateList *mOrderRepositoryMockAddOrUpdateList) Inspect(f func(ctx context.Context, opa1 []*order.Order)) *mOrderRepositoryMockAddOrUpdateList {
	if mmAddOrUpdateList.mock.inspectFuncAddOrUpdateList != nil {
		mmAddOrUpdateList.mock.t.Fatalf("Inspect function is already set for OrderRepositoryMock.AddOrUpdateList")
	}

	mmAddOrUpdateList.mock.inspectFuncAddOrUpdateList = f

	return mmAddOrUpdateList
}

// Return sets up results that will be returned by Repository.AddOrUpdateList
func (mmAddOrUpdateList *mOrderRepositoryMockAddOrUpdateList) Return(err error) *OrderRepositoryMock {
	if mmAddOrUpdateList.mock.funcAddOrUpdateList != nil {
		mmAddOrUpdateList.mock.t.Fatalf("OrderRepositoryMock.AddOrUpdateList mock is already set by Set")
	}

	if mmAddOrUpdateList.defaultExpectation == nil {
		mmAddOrUpdateList.defaultExpectation = &OrderRepositoryMockAddOrUpdateListExpectation{mock: mmAddOrUpdateList.mock}
	}
	mmAddOrUpdateList.defaultExpectation.results = &OrderRepositoryMockAddOrUpdateListResults{err}
	mmAddOrUpdateList.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmAddOrUpdateList.mock
}

// Set uses given function f to mock the Repository.AddOrUpdateList method
func (mmAddOrUpdateList *mOrderRepositoryMockAddOrUpdateList) Set(f func(ctx context.Context, opa1 []*order.Order) (err error)) *OrderRepositoryMock {
	if mmAddOrUpdateList.defaultExpectation != nil {
		mmAddOrUpdateList.mock.t.Fatalf("Default expectation is already set for the Repository.AddOrUpdateList method")
	}

	if len(mmAddOrUpdateList.expectations) > 0 {
		mmAddOrUpdateList.mock.t.Fatalf("Some expectations are already set for the Repository.AddOrUpdateList method")
	}

	mmAddOrUpdateList.mock.funcAddOrUpdateList = f
	mmAddOrUpdateList.mock.funcAddOrUpdateListOrigin = minimock.CallerInfo(1)
	return mmAddOrUpdateList.mock
}

// When sets expectation for the Repository.AddOrUpdateList which will trigger the result defined by the following
// Then helper
func (mmAddOrUpdateList *mOrderRepositoryMockAddOrUpdateList) When(ctx context.Context, opa1 []*order.Order) *OrderRepositoryMockAddOrUpdateListExpectation {
	if mmAddOrUpdateList.mock.funcAddOrUpdateList != nil {
		mmAddOrUpdateList.mock.t.Fatalf("OrderRepositoryMock.AddOrUpdateList mock is already set by Set")
	}

	expectation := &OrderRepositoryMockAddOrUpdateListExpectation{
		mock:               mmAddOrUpdateList.mock,
		params:             &OrderRepositoryMockAddOrUpdateListParams{ctx, opa1},
		expectationOrigins: OrderRepositoryMockAddOrUpdateListExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmAddOrUpdateList.expectations = append(mmAddOrUpdateList.expectations, expectation)
	return expectation
}

// Then sets up Repository.AddOrUpdateList return parameters for the expectation previously defined by the When method
func (e *OrderRepositoryMockAddOrUpdateListExpectation) Then(err error) *OrderRepositoryMock {
	e.results = &OrderRepositoryMockAddOrUpdateListResults{err}
	return e.mock
}

// Times sets number of times Repository.AddOrUpdateList should be invoked
func (mmAddOrUpdateList *mOrderRepositoryMockAddOrUpdateList) Times(n uint64) *mOrderRepositoryMockAddOrUpdateList {
	if n == 0 {
		mmAddOrUpdateList.mock.t.Fatalf("Times of OrderRepositoryMock.AddOrUpdateList mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAddOrUpdateList.expectedInvocations, n)
	mmAddOrUpdateList.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmAddOrUpdateList
}

func (mmAddOrUpdateList *mOrderRepositoryMockAddOrUpdateList) invocationsDone() bool {
	if len(mmAddOrUpdateList.expectations) == 0 && mmAddOrUpdateList.defaultExpectation == nil && mmAddOrUpdateList.mock.funcAddOrUpdateList == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAddOrUpdateList.mock.afterAddOrUpdateListCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAddOrUpdateList.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AddOrUpdateList implements mm_order.Repository
func (mmAddOrUpdateList *OrderRepositoryMock) AddOrUpdateList(ctx context.Context, opa1 []*order.Order) (err error) {
	mm_atomic.AddUint64(&mmAddOrUpdateList.beforeAddOrUpdateListCounter, 1)
	defer mm_atomic.AddUint64(&mmAddOrUpdateList.afterAddOrUpdateListCounter, 1)

	mmAddOrUpdateList.t.Helper()

	if mmAddOrUpdateList.inspectFuncAddOrUpdateList != nil {
		mmAddOrUpdateList.inspectFuncAddOrUpdateList(ctx, opa1)
	}

	mm_params := OrderRepositoryMockAddOrUpdateListParams{ctx, opa1}

	// Record call args
	mmAddOrUpdateList.AddOrUpdateListMock.mutex.Lock()
	mmAddOrUpdateList.AddOrUpdateListMock.callArgs = append(mmAddOrUpdateList.AddOrUpdateListMock.callArgs, &mm_params)
	mmAddOrUpdateList.AddOrUpdateListMock.mutex.Unlock()

	for _, e := range mmAddOrUpdateList.AddOrUpdateListMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmAddOrUpdateList.AddOrUpdateListMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddOrUpdateList.AddOrUpdateListMock.defaultExpectation.Counter, 1)
		mm_want := mmAddOrUpdateList.AddOrUpdateListMock.defaultExpectation.params
		mm_want_ptrs := mmAddOrUpdateList.AddOrUpdateListMock.defaultExpectation.paramPtrs

		mm_got := OrderRepositoryMockAddOrUpdateListParams{ctx, opa1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmAddOrUpdateList.t.Errorf("OrderRepositoryMock.AddOrUpdateList got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddOrUpdateList.AddOrUpdateListMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.opa1 != nil && !minimock.Equal(*mm_want_ptrs.opa1, mm_got.opa1) {
				mmAddOrUpdateList.t.Errorf("OrderRepositoryMock.AddOrUpdateList got unexpected parameter opa1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddOrUpdateList.AddOrUpdateListMock.defaultExpectation.expectationOrigins.originOpa1, *mm_want_ptrs.opa1, mm_got.opa1, minimock.Diff(*mm_want_ptrs.opa1, mm_got.opa1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddOrUpdateList.t.Errorf("OrderRepositoryMock.AddOrUpdateList got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmAddOrUpdateList.AddOrUpdateListMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddOrUpdateList.AddOrUpdateListMock.defaultExpectation.results
		if mm_results == nil {
			mmAddOrUpdateList.t.Fatal("No results are set for the OrderRepositoryMock.AddOrUpdateList")
		}
		return (*mm_results).err
	}
	if mmAddOrUpdateList.funcAddOrUpdateList != nil {
		return mmAddOrUpdateList.funcAddOrUpdateList(ctx, opa1)
	}
	mmAddOrUpdateList.t.Fatalf("Unexpected call to OrderRepositoryMock.AddOrUpdateList. %v %v", ctx, opa1)
	return
}

// AddOrUpdateListAfterCounter returns a count of finished OrderRepositoryMock.AddOrUpdateList invocations
func (mmAddOrUpdateList *OrderRepositoryMock) AddOrUpdateListAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddOrUpdateList.afterAddOrUpdateListCounter)
}

// AddOrUpdateListBeforeCounter returns a count of OrderRepositoryMock.AddOrUpdateList invocations
func (mmAddOrUpdateList *OrderRepositoryMock) AddOrUpdateListBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddOrUpdateList.beforeAddOrUpdateListCounter)
}

// Calls returns a list of arguments used in each call to OrderRepositoryMock.AddOrUpdateList.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddOrUpdateList *mOrderRepositoryMockAddOrUpdateList) Calls() []*OrderRepositoryMockAddOrUpdateListParams {
	mmAddOrUpdateList.mutex.RLock()

	argCopy := make([]*OrderRepositoryMockAddOrUpdateListParams, len(mmAddOrUpdateList.callArgs))
	copy(argCopy, mmAddOrUpdateList.callArgs)

	mmAddOrUpdateList.mutex.RUnlock()

	return argCopy
}

// MinimockAddOrUpdateListDone returns true if the count of the AddOrUpdateList invocations corresponds
// the number of defined expectations
func (m *OrderRepositoryMock) MinimockAddOrUpdateListDone() bool {
	if m.AddOrUpdateListMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AddOrUpdateListMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AddOrUpdateListMock.invocationsDone()
}

// MinimockAddOrUpdateListInspect logs each unmet expectation
func (m *OrderRepositoryMock) MinimockAddOrUpdateListInspect() {
	for _, e := range m.AddOrUpdateListMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OrderRepositoryMock.AddOrUpdateList at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterAddOrUpdateListCounter := mm_atomic.LoadUint64(&m.afterAddOrUpdateListCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AddOrUpdateListMock.defaultExpectation != nil && afterAddOrUpdateListCounter < 1 {
		if m.AddOrUpdateListMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to OrderRepositoryMock.AddOrUpdateList at\n%s", m.AddOrUpdateListMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to OrderRepositoryMock.AddOrUpdateList at\n%s with params: %#v", m.AddOrUpdateListMock.defaultExpectation.expectationOrigins.origin, *m.AddOrUpdateListMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddOrUpdateList != nil && afterAddOrUpdateListCounter < 1 {
		m.t.Errorf("Expected call to OrderRepositoryMock.AddOrUpdateList at\n%s", m.funcAddOrUpdateListOrigin)
	}

	if !m.AddOrUpdateListMock.invocationsDone() && afterAddOrUpdateListCounter > 0 {
		m.t.Errorf("Expected %d calls to OrderRepositoryMock.AddOrUpdateList at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.AddOrUpdateListMock.expectedInvocations), m.AddOrUpdateListMock.expectedInvocationsOrigin, afterAddOrUpdateListCounter)
	}
}

type mOrderRepositoryMockDelete struct {
	optional           bool
	mock               *OrderRepositoryMock
	defaultExpectation *OrderRepositoryMockDeleteExpectation
	expectations       []*OrderRepositoryMockDeleteExpectation

	callArgs []*OrderRepositoryMockDeleteParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// OrderRepositoryMockDeleteExpectation specifies expectation struct of the Repository.Delete
type OrderRepositoryMockDeleteExpectation struct {
	mock               *OrderRepositoryMock
	params             *OrderRepositoryMockDeleteParams
	paramPtrs          *OrderRepositoryMockDeleteParamPtrs
	expectationOrigins OrderRepositoryMockDeleteExpectationOrigins
	results            *OrderRepositoryMockDeleteResults
	returnOrigin       string
	Counter            uint64
}

// OrderRepositoryMockDeleteParams contains parameters of the Repository.Delete
type OrderRepositoryMockDeleteParams struct {
	ctx context.Context
	i1  basetypes.ID
}

// OrderRepositoryMockDeleteParamPtrs contains pointers to parameters of the Repository.Delete
type OrderRepositoryMockDeleteParamPtrs struct {
	ctx *context.Context
	i1  *basetypes.ID
}

// OrderRepositoryMockDeleteResults contains results of the Repository.Delete
type OrderRepositoryMockDeleteResults struct {
	err error
}

// OrderRepositoryMockDeleteOrigins contains origins of expectations of the Repository.Delete
type OrderRepositoryMockDeleteExpectationOrigins struct {
	origin    string
	originCtx string
	originI1  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDelete *mOrderRepositoryMockDelete) Optional() *mOrderRepositoryMockDelete {
	mmDelete.optional = true
	return mmDelete
}

// Expect sets up expected params for Repository.Delete
func (mmDelete *mOrderRepositoryMockDelete) Expect(ctx context.Context, i1 basetypes.ID) *mOrderRepositoryMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("OrderRepositoryMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &OrderRepositoryMockDeleteExpectation{}
	}

	if mmDelete.defaultExpectation.paramPtrs != nil {
		mmDelete.mock.t.Fatalf("OrderRepositoryMock.Delete mock is already set by ExpectParams functions")
	}

	mmDelete.defaultExpectation.params = &OrderRepositoryMockDeleteParams{ctx, i1}
	mmDelete.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDelete.expectations {
		if minimock.Equal(e.params, mmDelete.defaultExpectation.params) {
			mmDelete.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDelete.defaultExpectation.params)
		}
	}

	return mmDelete
}

// ExpectCtxParam1 sets up expected param ctx for Repository.Delete
func (mmDelete *mOrderRepositoryMockDelete) ExpectCtxParam1(ctx context.Context) *mOrderRepositoryMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("OrderRepositoryMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &OrderRepositoryMockDeleteExpectation{}
	}

	if mmDelete.defaultExpectation.params != nil {
		mmDelete.mock.t.Fatalf("OrderRepositoryMock.Delete mock is already set by Expect")
	}

	if mmDelete.defaultExpectation.paramPtrs == nil {
		mmDelete.defaultExpectation.paramPtrs = &OrderRepositoryMockDeleteParamPtrs{}
	}
	mmDelete.defaultExpectation.paramPtrs.ctx = &ctx
	mmDelete.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDelete
}

// ExpectI1Param2 sets up expected param i1 for Repository.Delete
func (mmDelete *mOrderRepositoryMockDelete) ExpectI1Param2(i1 basetypes.ID) *mOrderRepositoryMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("OrderRepositoryMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &OrderRepositoryMockDeleteExpectation{}
	}

	if mmDelete.defaultExpectation.params != nil {
		mmDelete.mock.t.Fatalf("OrderRepositoryMock.Delete mock is already set by Expect")
	}

	if mmDelete.defaultExpectation.paramPtrs == nil {
		mmDelete.defaultExpectation.paramPtrs = &OrderRepositoryMockDeleteParamPtrs{}
	}
	mmDelete.defaultExpectation.paramPtrs.i1 = &i1
	mmDelete.defaultExpectation.expectationOrigins.originI1 = minimock.CallerInfo(1)

	return mmDelete
}

// Inspect accepts an inspector function that has same arguments as the Repository.Delete
func (mmDelete *mOrderRepositoryMockDelete) Inspect(f func(ctx context.Context, i1 basetypes.ID)) *mOrderRepositoryMockDelete {
	if mmDelete.mock.inspectFuncDelete != nil {
		mmDelete.mock.t.Fatalf("Inspect function is already set for OrderRepositoryMock.Delete")
	}

	mmDelete.mock.inspectFuncDelete = f

	return mmDelete
}

// Return sets up results that will be returned by Repository.Delete
func (mmDelete *mOrderRepositoryMockDelete) Return(err error) *OrderRepositoryMock {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("OrderRepositoryMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &OrderRepositoryMockDeleteExpectation{mock: mmDelete.mock}
	}
	mmDelete.defaultExpectation.results = &OrderRepositoryMockDeleteResults{err}
	mmDelete.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDelete.mock
}

// Set uses given function f to mock the Repository.Delete method
func (mmDelete *mOrderRepositoryMockDelete) Set(f func(ctx context.Context, i1 basetypes.ID) (err error)) *OrderRepositoryMock {
	if mmDelete.defaultExpectation != nil {
		mmDelete.mock.t.Fatalf("Default expectation is already set for the Repository.Delete method")
	}

	if len(mmDelete.expectations) > 0 {
		mmDelete.mock.t.Fatalf("Some expectations are already set for the Repository.Delete method")
	}

	mmDelete.mock.funcDelete = f
	mmDelete.mock.funcDeleteOrigin = minimock.CallerInfo(1)
	return mmDelete.mock
}

// When sets expectation for the Repository.Delete which will trigger the result defined by the following
// Then helper
func (mmDelete *mOrderRepositoryMockDelete) When(ctx context.Context, i1 basetypes.ID) *OrderRepositoryMockDeleteExpectation {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("OrderRepositoryMock.Delete mock is already set by Set")
	}

	expectation := &OrderRepositoryMockDeleteExpectation{
		mock:               mmDelete.mock,
		params:             &OrderRepositoryMockDeleteParams{ctx, i1},
		expectationOrigins: OrderRepositoryMockDeleteExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDelete.expectations = append(mmDelete.expectations, expectation)
	return expectation
}

// Then sets up Repository.Delete return parameters for the expectation previously defined by the When method
func (e *OrderRepositoryMockDeleteExpectation) Then(err error) *OrderRepositoryMock {
	e.results = &OrderRepositoryMockDeleteResults{err}
	return e.mock
}

// Times sets number of times Repository.Delete should be invoked
func (mmDelete *mOrderRepositoryMockDelete) Times(n uint64) *mOrderRepositoryMockDelete {
	if n == 0 {
		mmDelete.mock.t.Fatalf("Times of OrderRepositoryMock.Delete mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDelete.expectedInvocations, n)
	mmDelete.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDelete
}

func (mmDelete *mOrderRepositoryMockDelete) invocationsDone() bool {
	if len(mmDelete.expectations) == 0 && mmDelete.defaultExpectation == nil && mmDelete.mock.funcDelete == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDelete.mock.afterDeleteCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDelete.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Delete implements mm_order.Repository
func (mmDelete *OrderRepositoryMock) Delete(ctx context.Context, i1 basetypes.ID) (err error) {
	mm_atomic.AddUint64(&mmDelete.beforeDeleteCounter, 1)
	defer mm_atomic.AddUint64(&mmDelete.afterDeleteCounter, 1)

	mmDelete.t.Helper()

	if mmDelete.inspectFuncDelete != nil {
		mmDelete.inspectFuncDelete(ctx, i1)
	}

	mm_params := OrderRepositoryMockDeleteParams{ctx, i1}

	// Record call args
	mmDelete.DeleteMock.mutex.Lock()
	mmDelete.DeleteMock.callArgs = append(mmDelete.DeleteMock.callArgs, &mm_params)
	mmDelete.DeleteMock.mutex.Unlock()

	for _, e := range mmDelete.DeleteMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDelete.DeleteMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDelete.DeleteMock.defaultExpectation.Counter, 1)
		mm_want := mmDelete.DeleteMock.defaultExpectation.params
		mm_want_ptrs := mmDelete.DeleteMock.defaultExpectation.paramPtrs

		mm_got := OrderRepositoryMockDeleteParams{ctx, i1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDelete.t.Errorf("OrderRepositoryMock.Delete got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDelete.DeleteMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.i1 != nil && !minimock.Equal(*mm_want_ptrs.i1, mm_got.i1) {
				mmDelete.t.Errorf("OrderRepositoryMock.Delete got unexpected parameter i1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDelete.DeleteMock.defaultExpectation.expectationOrigins.originI1, *mm_want_ptrs.i1, mm_got.i1, minimock.Diff(*mm_want_ptrs.i1, mm_got.i1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDelete.t.Errorf("OrderRepositoryMock.Delete got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDelete.DeleteMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDelete.DeleteMock.defaultExpectation.results
		if mm_results == nil {
			mmDelete.t.Fatal("No results are set for the OrderRepositoryMock.Delete")
		}
		return (*mm_results).err
	}
	if mmDelete.funcDelete != nil {
		return mmDelete.funcDelete(ctx, i1)
	}
	mmDelete.t.Fatalf("Unexpected call to OrderRepositoryMock.Delete. %v %v", ctx, i1)
	return
}

// DeleteAfterCounter returns a count of finished OrderRepositoryMock.Delete invocations
func (mmDelete *OrderRepositoryMock) DeleteAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.afterDeleteCounter)
}

// DeleteBeforeCounter returns a count of OrderRepositoryMock.Delete invocations
func (mmDelete *OrderRepositoryMock) DeleteBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.beforeDeleteCounter)
}

// Calls returns a list of arguments used in each call to OrderRepositoryMock.Delete.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDelete *mOrderRepositoryMockDelete) Calls() []*OrderRepositoryMockDeleteParams {
	mmDelete.mutex.RLock()

	argCopy := make([]*OrderRepositoryMockDeleteParams, len(mmDelete.callArgs))
	copy(argCopy, mmDelete.callArgs)

	mmDelete.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteDone returns true if the count of the Delete invocations corresponds
// the number of defined expectations
func (m *OrderRepositoryMock) MinimockDeleteDone() bool {
	if m.DeleteMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteMock.invocationsDone()
}

// MinimockDeleteInspect logs each unmet expectation
func (m *OrderRepositoryMock) MinimockDeleteInspect() {
	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OrderRepositoryMock.Delete at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteCounter := mm_atomic.LoadUint64(&m.afterDeleteCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteMock.defaultExpectation != nil && afterDeleteCounter < 1 {
		if m.DeleteMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to OrderRepositoryMock.Delete at\n%s", m.DeleteMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to OrderRepositoryMock.Delete at\n%s with params: %#v", m.DeleteMock.defaultExpectation.expectationOrigins.origin, *m.DeleteMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDelete != nil && afterDeleteCounter < 1 {
		m.t.Errorf("Expected call to OrderRepositoryMock.Delete at\n%s", m.funcDeleteOrigin)
	}

	if !m.DeleteMock.invocationsDone() && afterDeleteCounter > 0 {
		m.t.Errorf("Expected %d calls to OrderRepositoryMock.Delete at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteMock.expectedInvocations), m.DeleteMock.expectedInvocationsOrigin, afterDeleteCounter)
	}
}

type mOrderRepositoryMockDeleteBy struct {
	optional           bool
	mock               *OrderRepositoryMock
	defaultExpectation *OrderRepositoryMockDeleteByExpectation
	expectations       []*OrderRepositoryMockDeleteByExpectation

	callArgs []*OrderRepositoryMockDeleteByParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// OrderRepositoryMockDeleteByExpectation specifies expectation struct of the Repository.DeleteBy
type OrderRepositoryMockDeleteByExpectation struct {
	mock               *OrderRepositoryMock
	params             *OrderRepositoryMockDeleteByParams
	paramPtrs          *OrderRepositoryMockDeleteByParamPtrs
	expectationOrigins OrderRepositoryMockDeleteByExpectationOrigins
	results            *OrderRepositoryMockDeleteByResults
	returnOrigin       string
	Counter            uint64
}

// OrderRepositoryMockDeleteByParams contains parameters of the Repository.DeleteBy
type OrderRepositoryMockDeleteByParams struct {
	ctx context.Context
	fp1 *order.Filter
}

// OrderRepositoryMockDeleteByParamPtrs contains pointers to parameters of the Repository.DeleteBy
type OrderRepositoryMockDeleteByParamPtrs struct {
	ctx *context.Context
	fp1 **order.Filter
}

// OrderRepositoryMockDeleteByResults contains results of the Repository.DeleteBy
type OrderRepositoryMockDeleteByResults struct {
	err error
}

// OrderRepositoryMockDeleteByOrigins contains origins of expectations of the Repository.DeleteBy
type OrderRepositoryMockDeleteByExpectationOrigins struct {
	origin    string
	originCtx string
	originFp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteBy *mOrderRepositoryMockDeleteBy) Optional() *mOrderRepositoryMockDeleteBy {
	mmDeleteBy.optional = true
	return mmDeleteBy
}

// Expect sets up expected params for Repository.DeleteBy
func (mmDeleteBy *mOrderRepositoryMockDeleteBy) Expect(ctx context.Context, fp1 *order.Filter) *mOrderRepositoryMockDeleteBy {
	if mmDeleteBy.mock.funcDeleteBy != nil {
		mmDeleteBy.mock.t.Fatalf("OrderRepositoryMock.DeleteBy mock is already set by Set")
	}

	if mmDeleteBy.defaultExpectation == nil {
		mmDeleteBy.defaultExpectation = &OrderRepositoryMockDeleteByExpectation{}
	}

	if mmDeleteBy.defaultExpectation.paramPtrs != nil {
		mmDeleteBy.mock.t.Fatalf("OrderRepositoryMock.DeleteBy mock is already set by ExpectParams functions")
	}

	mmDeleteBy.defaultExpectation.params = &OrderRepositoryMockDeleteByParams{ctx, fp1}
	mmDeleteBy.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteBy.expectations {
		if minimock.Equal(e.params, mmDeleteBy.defaultExpectation.params) {
			mmDeleteBy.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteBy.defaultExpectation.params)
		}
	}

	return mmDeleteBy
}

// ExpectCtxParam1 sets up expected param ctx for Repository.DeleteBy
func (mmDeleteBy *mOrderRepositoryMockDeleteBy) ExpectCtxParam1(ctx context.Context) *mOrderRepositoryMockDeleteBy {
	if mmDeleteBy.mock.funcDeleteBy != nil {
		mmDeleteBy.mock.t.Fatalf("OrderRepositoryMock.DeleteBy mock is already set by Set")
	}

	if mmDeleteBy.defaultExpectation == nil {
		mmDeleteBy.defaultExpectation = &OrderRepositoryMockDeleteByExpectation{}
	}

	if mmDeleteBy.defaultExpectation.params != nil {
		mmDeleteBy.mock.t.Fatalf("OrderRepositoryMock.DeleteBy mock is already set by Expect")
	}

	if mmDeleteBy.defaultExpectation.paramPtrs == nil {
		mmDeleteBy.defaultExpectation.paramPtrs = &OrderRepositoryMockDeleteByParamPtrs{}
	}
	mmDeleteBy.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteBy.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteBy
}

// ExpectFp1Param2 sets up expected param fp1 for Repository.DeleteBy
func (mmDeleteBy *mOrderRepositoryMockDeleteBy) ExpectFp1Param2(fp1 *order.Filter) *mOrderRepositoryMockDeleteBy {
	if mmDeleteBy.mock.funcDeleteBy != nil {
		mmDeleteBy.mock.t.Fatalf("OrderRepositoryMock.DeleteBy mock is already set by Set")
	}

	if mmDeleteBy.defaultExpectation == nil {
		mmDeleteBy.defaultExpectation = &OrderRepositoryMockDeleteByExpectation{}
	}

	if mmDeleteBy.defaultExpectation.params != nil {
		mmDeleteBy.mock.t.Fatalf("OrderRepositoryMock.DeleteBy mock is already set by Expect")
	}

	if mmDeleteBy.defaultExpectation.paramPtrs == nil {
		mmDeleteBy.defaultExpectation.paramPtrs = &OrderRepositoryMockDeleteByParamPtrs{}
	}
	mmDeleteBy.defaultExpectation.paramPtrs.fp1 = &fp1
	mmDeleteBy.defaultExpectation.expectationOrigins.originFp1 = minimock.CallerInfo(1)

	return mmDeleteBy
}

// Inspect accepts an inspector function that has same arguments as the Repository.DeleteBy
func (mmDeleteBy *mOrderRepositoryMockDeleteBy) Inspect(f func(ctx context.Context, fp1 *order.Filter)) *mOrderRepositoryMockDeleteBy {
	if mmDeleteBy.mock.inspectFuncDeleteBy != nil {
		mmDeleteBy.mock.t.Fatalf("Inspect function is already set for OrderRepositoryMock.DeleteBy")
	}

	mmDeleteBy.mock.inspectFuncDeleteBy = f

	return mmDeleteBy
}

// Return sets up results that will be returned by Repository.DeleteBy
func (mmDeleteBy *mOrderRepositoryMockDeleteBy) Return(err error) *OrderRepositoryMock {
	if mmDeleteBy.mock.funcDeleteBy != nil {
		mmDeleteBy.mock.t.Fatalf("OrderRepositoryMock.DeleteBy mock is already set by Set")
	}

	if mmDeleteBy.defaultExpectation == nil {
		mmDeleteBy.defaultExpectation = &OrderRepositoryMockDeleteByExpectation{mock: mmDeleteBy.mock}
	}
	mmDeleteBy.defaultExpectation.results = &OrderRepositoryMockDeleteByResults{err}
	mmDeleteBy.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteBy.mock
}

// Set uses given function f to mock the Repository.DeleteBy method
func (mmDeleteBy *mOrderRepositoryMockDeleteBy) Set(f func(ctx context.Context, fp1 *order.Filter) (err error)) *OrderRepositoryMock {
	if mmDeleteBy.defaultExpectation != nil {
		mmDeleteBy.mock.t.Fatalf("Default expectation is already set for the Repository.DeleteBy method")
	}

	if len(mmDeleteBy.expectations) > 0 {
		mmDeleteBy.mock.t.Fatalf("Some expectations are already set for the Repository.DeleteBy method")
	}

	mmDeleteBy.mock.funcDeleteBy = f
	mmDeleteBy.mock.funcDeleteByOrigin = minimock.CallerInfo(1)
	return mmDeleteBy.mock
}

// When sets expectation for the Repository.DeleteBy which will trigger the result defined by the following
// Then helper
func (mmDeleteBy *mOrderRepositoryMockDeleteBy) When(ctx context.Context, fp1 *order.Filter) *OrderRepositoryMockDeleteByExpectation {
	if mmDeleteBy.mock.funcDeleteBy != nil {
		mmDeleteBy.mock.t.Fatalf("OrderRepositoryMock.DeleteBy mock is already set by Set")
	}

	expectation := &OrderRepositoryMockDeleteByExpectation{
		mock:               mmDeleteBy.mock,
		params:             &OrderRepositoryMockDeleteByParams{ctx, fp1},
		expectationOrigins: OrderRepositoryMockDeleteByExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteBy.expectations = append(mmDeleteBy.expectations, expectation)
	return expectation
}

// Then sets up Repository.DeleteBy return parameters for the expectation previously defined by the When method
func (e *OrderRepositoryMockDeleteByExpectation) Then(err error) *OrderRepositoryMock {
	e.results = &OrderRepositoryMockDeleteByResults{err}
	return e.mock
}

// Times sets number of times Repository.DeleteBy should be invoked
func (mmDeleteBy *mOrderRepositoryMockDeleteBy) Times(n uint64) *mOrderRepositoryMockDeleteBy {
	if n == 0 {
		mmDeleteBy.mock.t.Fatalf("Times of OrderRepositoryMock.DeleteBy mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteBy.expectedInvocations, n)
	mmDeleteBy.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteBy
}

func (mmDeleteBy *mOrderRepositoryMockDeleteBy) invocationsDone() bool {
	if len(mmDeleteBy.expectations) == 0 && mmDeleteBy.defaultExpectation == nil && mmDeleteBy.mock.funcDeleteBy == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteBy.mock.afterDeleteByCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteBy.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteBy implements mm_order.Repository
func (mmDeleteBy *OrderRepositoryMock) DeleteBy(ctx context.Context, fp1 *order.Filter) (err error) {
	mm_atomic.AddUint64(&mmDeleteBy.beforeDeleteByCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteBy.afterDeleteByCounter, 1)

	mmDeleteBy.t.Helper()

	if mmDeleteBy.inspectFuncDeleteBy != nil {
		mmDeleteBy.inspectFuncDeleteBy(ctx, fp1)
	}

	mm_params := OrderRepositoryMockDeleteByParams{ctx, fp1}

	// Record call args
	mmDeleteBy.DeleteByMock.mutex.Lock()
	mmDeleteBy.DeleteByMock.callArgs = append(mmDeleteBy.DeleteByMock.callArgs, &mm_params)
	mmDeleteBy.DeleteByMock.mutex.Unlock()

	for _, e := range mmDeleteBy.DeleteByMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteBy.DeleteByMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteBy.DeleteByMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteBy.DeleteByMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteBy.DeleteByMock.defaultExpectation.paramPtrs

		mm_got := OrderRepositoryMockDeleteByParams{ctx, fp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteBy.t.Errorf("OrderRepositoryMock.DeleteBy got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteBy.DeleteByMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.fp1 != nil && !minimock.Equal(*mm_want_ptrs.fp1, mm_got.fp1) {
				mmDeleteBy.t.Errorf("OrderRepositoryMock.DeleteBy got unexpected parameter fp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteBy.DeleteByMock.defaultExpectation.expectationOrigins.originFp1, *mm_want_ptrs.fp1, mm_got.fp1, minimock.Diff(*mm_want_ptrs.fp1, mm_got.fp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteBy.t.Errorf("OrderRepositoryMock.DeleteBy got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteBy.DeleteByMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteBy.DeleteByMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteBy.t.Fatal("No results are set for the OrderRepositoryMock.DeleteBy")
		}
		return (*mm_results).err
	}
	if mmDeleteBy.funcDeleteBy != nil {
		return mmDeleteBy.funcDeleteBy(ctx, fp1)
	}
	mmDeleteBy.t.Fatalf("Unexpected call to OrderRepositoryMock.DeleteBy. %v %v", ctx, fp1)
	return
}

// DeleteByAfterCounter returns a count of finished OrderRepositoryMock.DeleteBy invocations
func (mmDeleteBy *OrderRepositoryMock) DeleteByAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteBy.afterDeleteByCounter)
}

// DeleteByBeforeCounter returns a count of OrderRepositoryMock.DeleteBy invocations
func (mmDeleteBy *OrderRepositoryMock) DeleteByBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteBy.beforeDeleteByCounter)
}

// Calls returns a list of arguments used in each call to OrderRepositoryMock.DeleteBy.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteBy *mOrderRepositoryMockDeleteBy) Calls() []*OrderRepositoryMockDeleteByParams {
	mmDeleteBy.mutex.RLock()

	argCopy := make([]*OrderRepositoryMockDeleteByParams, len(mmDeleteBy.callArgs))
	copy(argCopy, mmDeleteBy.callArgs)

	mmDeleteBy.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteByDone returns true if the count of the DeleteBy invocations corresponds
// the number of defined expectations
func (m *OrderRepositoryMock) MinimockDeleteByDone() bool {
	if m.DeleteByMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteByMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteByMock.invocationsDone()
}

// MinimockDeleteByInspect logs each unmet expectation
func (m *OrderRepositoryMock) MinimockDeleteByInspect() {
	for _, e := range m.DeleteByMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OrderRepositoryMock.DeleteBy at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteByCounter := mm_atomic.LoadUint64(&m.afterDeleteByCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteByMock.defaultExpectation != nil && afterDeleteByCounter < 1 {
		if m.DeleteByMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to OrderRepositoryMock.DeleteBy at\n%s", m.DeleteByMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to OrderRepositoryMock.DeleteBy at\n%s with params: %#v", m.DeleteByMock.defaultExpectation.expectationOrigins.origin, *m.DeleteByMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteBy != nil && afterDeleteByCounter < 1 {
		m.t.Errorf("Expected call to OrderRepositoryMock.DeleteBy at\n%s", m.funcDeleteByOrigin)
	}

	if !m.DeleteByMock.invocationsDone() && afterDeleteByCounter > 0 {
		m.t.Errorf("Expected %d calls to OrderRepositoryMock.DeleteBy at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteByMock.expectedInvocations), m.DeleteByMock.expectedInvocationsOrigin, afterDeleteByCounter)
	}
}

type mOrderRepositoryMockGet struct {
	optional           bool
	mock               *OrderRepositoryMock
	defaultExpectation *OrderRepositoryMockGetExpectation
	expectations       []*OrderRepositoryMockGetExpectation

	callArgs []*OrderRepositoryMockGetParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// OrderRepositoryMockGetExpectation specifies expectation struct of the Repository.Get
type OrderRepositoryMockGetExpectation struct {
	mock               *OrderRepositoryMock
	params             *OrderRepositoryMockGetParams
	paramPtrs          *OrderRepositoryMockGetParamPtrs
	expectationOrigins OrderRepositoryMockGetExpectationOrigins
	results            *OrderRepositoryMockGetResults
	returnOrigin       string
	Counter            uint64
}

// OrderRepositoryMockGetParams contains parameters of the Repository.Get
type OrderRepositoryMockGetParams struct {
	ctx context.Context
	i1  basetypes.ID
}

// OrderRepositoryMockGetParamPtrs contains pointers to parameters of the Repository.Get
type OrderRepositoryMockGetParamPtrs struct {
	ctx *context.Context
	i1  *basetypes.ID
}

// OrderRepositoryMockGetResults contains results of the Repository.Get
type OrderRepositoryMockGetResults struct {
	op1 *order.Order
	err error
}

// OrderRepositoryMockGetOrigins contains origins of expectations of the Repository.Get
type OrderRepositoryMockGetExpectationOrigins struct {
	origin    string
	originCtx string
	originI1  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGet *mOrderRepositoryMockGet) Optional() *mOrderRepositoryMockGet {
	mmGet.optional = true
	return mmGet
}

// Expect sets up expected params for Repository.Get
func (mmGet *mOrderRepositoryMockGet) Expect(ctx context.Context, i1 basetypes.ID) *mOrderRepositoryMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("OrderRepositoryMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &OrderRepositoryMockGetExpectation{}
	}

	if mmGet.defaultExpectation.paramPtrs != nil {
		mmGet.mock.t.Fatalf("OrderRepositoryMock.Get mock is already set by ExpectParams functions")
	}

	mmGet.defaultExpectation.params = &OrderRepositoryMockGetParams{ctx, i1}
	mmGet.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGet.expectations {
		if minimock.Equal(e.params, mmGet.defaultExpectation.params) {
			mmGet.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGet.defaultExpectation.params)
		}
	}

	return mmGet
}

// ExpectCtxParam1 sets up expected param ctx for Repository.Get
func (mmGet *mOrderRepositoryMockGet) ExpectCtxParam1(ctx context.Context) *mOrderRepositoryMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("OrderRepositoryMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &OrderRepositoryMockGetExpectation{}
	}

	if mmGet.defaultExpectation.params != nil {
		mmGet.mock.t.Fatalf("OrderRepositoryMock.Get mock is already set by Expect")
	}

	if mmGet.defaultExpectation.paramPtrs == nil {
		mmGet.defaultExpectation.paramPtrs = &OrderRepositoryMockGetParamPtrs{}
	}
	mmGet.defaultExpectation.paramPtrs.ctx = &ctx
	mmGet.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGet
}

// ExpectI1Param2 sets up expected param i1 for Repository.Get
func (mmGet *mOrderRepositoryMockGet) ExpectI1Param2(i1 basetypes.ID) *mOrderRepositoryMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("OrderRepositoryMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &OrderRepositoryMockGetExpectation{}
	}

	if mmGet.defaultExpectation.params != nil {
		mmGet.mock.t.Fatalf("OrderRepositoryMock.Get mock is already set by Expect")
	}

	if mmGet.defaultExpectation.paramPtrs == nil {
		mmGet.defaultExpectation.paramPtrs = &OrderRepositoryMockGetParamPtrs{}
	}
	mmGet.defaultExpectation.paramPtrs.i1 = &i1
	mmGet.defaultExpectation.expectationOrigins.originI1 = minimock.CallerInfo(1)

	return mmGet
}

// Inspect accepts an inspector function that has same arguments as the Repository.Get
func (mmGet *mOrderRepositoryMockGet) Inspect(f func(ctx context.Context, i1 basetypes.ID)) *mOrderRepositoryMockGet {
	if mmGet.mock.inspectFuncGet != nil {
		mmGet.mock.t.Fatalf("Inspect function is already set for OrderRepositoryMock.Get")
	}

	mmGet.mock.inspectFuncGet = f

	return mmGet
}

// Return sets up results that will be returned by Repository.Get
func (mmGet *mOrderRepositoryMockGet) Return(op1 *order.Order, err error) *OrderRepositoryMock {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("OrderRepositoryMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &OrderRepositoryMockGetExpectation{mock: mmGet.mock}
	}
	mmGet.defaultExpectation.results = &OrderRepositoryMockGetResults{op1, err}
	mmGet.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGet.mock
}

// Set uses given function f to mock the Repository.Get method
func (mmGet *mOrderRepositoryMockGet) Set(f func(ctx context.Context, i1 basetypes.ID) (op1 *order.Order, err error)) *OrderRepositoryMock {
	if mmGet.defaultExpectation != nil {
		mmGet.mock.t.Fatalf("Default expectation is already set for the Repository.Get method")
	}

	if len(mmGet.expectations) > 0 {
		mmGet.mock.t.Fatalf("Some expectations are already set for the Repository.Get method")
	}

	mmGet.mock.funcGet = f
	mmGet.mock.funcGetOrigin = minimock.CallerInfo(1)
	return mmGet.mock
}

// When sets expectation for the Repository.Get which will trigger the result defined by the following
// Then helper
func (mmGet *mOrderRepositoryMockGet) When(ctx context.Context, i1 basetypes.ID) *OrderRepositoryMockGetExpectation {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("OrderRepositoryMock.Get mock is already set by Set")
	}

	expectation := &OrderRepositoryMockGetExpectation{
		mock:               mmGet.mock,
		params:             &OrderRepositoryMockGetParams{ctx, i1},
		expectationOrigins: OrderRepositoryMockGetExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGet.expectations = append(mmGet.expectations, expectation)
	return expectation
}

// Then sets up Repository.Get return parameters for the expectation previously defined by the When method
func (e *OrderRepositoryMockGetExpectation) Then(op1 *order.Order, err error) *OrderRepositoryMock {
	e.results = &OrderRepositoryMockGetResults{op1, err}
	return e.mock
}

// Times sets number of times Repository.Get should be invoked
func (mmGet *mOrderRepositoryMockGet) Times(n uint64) *mOrderRepositoryMockGet {
	if n == 0 {
		mmGet.mock.t.Fatalf("Times of OrderRepositoryMock.Get mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGet.expectedInvocations, n)
	mmGet.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGet
}

func (mmGet *mOrderRepositoryMockGet) invocationsDone() bool {
	if len(mmGet.expectations) == 0 && mmGet.defaultExpectation == nil && mmGet.mock.funcGet == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGet.mock.afterGetCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGet.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Get implements mm_order.Repository
func (mmGet *OrderRepositoryMock) Get(ctx context.Context, i1 basetypes.ID) (op1 *order.Order, err error) {
	mm_atomic.AddUint64(&mmGet.beforeGetCounter, 1)
	defer mm_atomic.AddUint64(&mmGet.afterGetCounter, 1)

	mmGet.t.Helper()

	if mmGet.inspectFuncGet != nil {
		mmGet.inspectFuncGet(ctx, i1)
	}

	mm_params := OrderRepositoryMockGetParams{ctx, i1}

	// Record call args
	mmGet.GetMock.mutex.Lock()
	mmGet.GetMock.callArgs = append(mmGet.GetMock.callArgs, &mm_params)
	mmGet.GetMock.mutex.Unlock()

	for _, e := range mmGet.GetMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.op1, e.results.err
		}
	}

	if mmGet.GetMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGet.GetMock.defaultExpectation.Counter, 1)
		mm_want := mmGet.GetMock.defaultExpectation.params
		mm_want_ptrs := mmGet.GetMock.defaultExpectation.paramPtrs

		mm_got := OrderRepositoryMockGetParams{ctx, i1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGet.t.Errorf("OrderRepositoryMock.Get got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGet.GetMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.i1 != nil && !minimock.Equal(*mm_want_ptrs.i1, mm_got.i1) {
				mmGet.t.Errorf("OrderRepositoryMock.Get got unexpected parameter i1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGet.GetMock.defaultExpectation.expectationOrigins.originI1, *mm_want_ptrs.i1, mm_got.i1, minimock.Diff(*mm_want_ptrs.i1, mm_got.i1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGet.t.Errorf("OrderRepositoryMock.Get got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGet.GetMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGet.GetMock.defaultExpectation.results
		if mm_results == nil {
			mmGet.t.Fatal("No results are set for the OrderRepositoryMock.Get")
		}
		return (*mm_results).op1, (*mm_results).err
	}
	if mmGet.funcGet != nil {
		return mmGet.funcGet(ctx, i1)
	}
	mmGet.t.Fatalf("Unexpected call to OrderRepositoryMock.Get. %v %v", ctx, i1)
	return
}

// GetAfterCounter returns a count of finished OrderRepositoryMock.Get invocations
func (mmGet *OrderRepositoryMock) GetAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGet.afterGetCounter)
}

// GetBeforeCounter returns a count of OrderRepositoryMock.Get invocations
func (mmGet *OrderRepositoryMock) GetBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGet.beforeGetCounter)
}

// Calls returns a list of arguments used in each call to OrderRepositoryMock.Get.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGet *mOrderRepositoryMockGet) Calls() []*OrderRepositoryMockGetParams {
	mmGet.mutex.RLock()

	argCopy := make([]*OrderRepositoryMockGetParams, len(mmGet.callArgs))
	copy(argCopy, mmGet.callArgs)

	mmGet.mutex.RUnlock()

	return argCopy
}

// MinimockGetDone returns true if the count of the Get invocations corresponds
// the number of defined expectations
func (m *OrderRepositoryMock) MinimockGetDone() bool {
	if m.GetMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetMock.invocationsDone()
}

// MinimockGetInspect logs each unmet expectation
func (m *OrderRepositoryMock) MinimockGetInspect() {
	for _, e := range m.GetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OrderRepositoryMock.Get at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetCounter := mm_atomic.LoadUint64(&m.afterGetCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetMock.defaultExpectation != nil && afterGetCounter < 1 {
		if m.GetMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to OrderRepositoryMock.Get at\n%s", m.GetMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to OrderRepositoryMock.Get at\n%s with params: %#v", m.GetMock.defaultExpectation.expectationOrigins.origin, *m.GetMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGet != nil && afterGetCounter < 1 {
		m.t.Errorf("Expected call to OrderRepositoryMock.Get at\n%s", m.funcGetOrigin)
	}

	if !m.GetMock.invocationsDone() && afterGetCounter > 0 {
		m.t.Errorf("Expected %d calls to OrderRepositoryMock.Get at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetMock.expectedInvocations), m.GetMock.expectedInvocationsOrigin, afterGetCounter)
	}
}

type mOrderRepositoryMockGetBy struct {
	optional           bool
	mock               *OrderRepositoryMock
	defaultExpectation *OrderRepositoryMockGetByExpectation
	expectations       []*OrderRepositoryMockGetByExpectation

	callArgs []*OrderRepositoryMockGetByParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// OrderRepositoryMockGetByExpectation specifies expectation struct of the Repository.GetBy
type OrderRepositoryMockGetByExpectation struct {
	mock               *OrderRepositoryMock
	params             *OrderRepositoryMockGetByParams
	paramPtrs          *OrderRepositoryMockGetByParamPtrs
	expectationOrigins OrderRepositoryMockGetByExpectationOrigins
	results            *OrderRepositoryMockGetByResults
	returnOrigin       string
	Counter            uint64
}

// OrderRepositoryMockGetByParams contains parameters of the Repository.GetBy
type OrderRepositoryMockGetByParams struct {
	ctx context.Context
	fp1 *order.Filter
}

// OrderRepositoryMockGetByParamPtrs contains pointers to parameters of the Repository.GetBy
type OrderRepositoryMockGetByParamPtrs struct {
	ctx *context.Context
	fp1 **order.Filter
}

// OrderRepositoryMockGetByResults contains results of the Repository.GetBy
type OrderRepositoryMockGetByResults struct {
	opa1 []*order.Order
	err  error
}

// OrderRepositoryMockGetByOrigins contains origins of expectations of the Repository.GetBy
type OrderRepositoryMockGetByExpectationOrigins struct {
	origin    string
	originCtx string
	originFp1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetBy *mOrderRepositoryMockGetBy) Optional() *mOrderRepositoryMockGetBy {
	mmGetBy.optional = true
	return mmGetBy
}

// Expect sets up expected params for Repository.GetBy
func (mmGetBy *mOrderRepositoryMockGetBy) Expect(ctx context.Context, fp1 *order.Filter) *mOrderRepositoryMockGetBy {
	if mmGetBy.mock.funcGetBy != nil {
		mmGetBy.mock.t.Fatalf("OrderRepositoryMock.GetBy mock is already set by Set")
	}

	if mmGetBy.defaultExpectation == nil {
		mmGetBy.defaultExpectation = &OrderRepositoryMockGetByExpectation{}
	}

	if mmGetBy.defaultExpectation.paramPtrs != nil {
		mmGetBy.mock.t.Fatalf("OrderRepositoryMock.GetBy mock is already set by ExpectParams functions")
	}

	mmGetBy.defaultExpectation.params = &OrderRepositoryMockGetByParams{ctx, fp1}
	mmGetBy.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetBy.expectations {
		if minimock.Equal(e.params, mmGetBy.defaultExpectation.params) {
			mmGetBy.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetBy.defaultExpectation.params)
		}
	}

	return mmGetBy
}

// ExpectCtxParam1 sets up expected param ctx for Repository.GetBy
func (mmGetBy *mOrderRepositoryMockGetBy) ExpectCtxParam1(ctx context.Context) *mOrderRepositoryMockGetBy {
	if mmGetBy.mock.funcGetBy != nil {
		mmGetBy.mock.t.Fatalf("OrderRepositoryMock.GetBy mock is already set by Set")
	}

	if mmGetBy.defaultExpectation == nil {
		mmGetBy.defaultExpectation = &OrderRepositoryMockGetByExpectation{}
	}

	if mmGetBy.defaultExpectation.params != nil {
		mmGetBy.mock.t.Fatalf("OrderRepositoryMock.GetBy mock is already set by Expect")
	}

	if mmGetBy.defaultExpectation.paramPtrs == nil {
		mmGetBy.defaultExpectation.paramPtrs = &OrderRepositoryMockGetByParamPtrs{}
	}
	mmGetBy.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetBy.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetBy
}

// ExpectFp1Param2 sets up expected param fp1 for Repository.GetBy
func (mmGetBy *mOrderRepositoryMockGetBy) ExpectFp1Param2(fp1 *order.Filter) *mOrderRepositoryMockGetBy {
	if mmGetBy.mock.funcGetBy != nil {
		mmGetBy.mock.t.Fatalf("OrderRepositoryMock.GetBy mock is already set by Set")
	}

	if mmGetBy.defaultExpectation == nil {
		mmGetBy.defaultExpectation = &OrderRepositoryMockGetByExpectation{}
	}

	if mmGetBy.defaultExpectation.params != nil {
		mmGetBy.mock.t.Fatalf("OrderRepositoryMock.GetBy mock is already set by Expect")
	}

	if mmGetBy.defaultExpectation.paramPtrs == nil {
		mmGetBy.defaultExpectation.paramPtrs = &OrderRepositoryMockGetByParamPtrs{}
	}
	mmGetBy.defaultExpectation.paramPtrs.fp1 = &fp1
	mmGetBy.defaultExpectation.expectationOrigins.originFp1 = minimock.CallerInfo(1)

	return mmGetBy
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetBy
func (mmGetBy *mOrderRepositoryMockGetBy) Inspect(f func(ctx context.Context, fp1 *order.Filter)) *mOrderRepositoryMockGetBy {
	if mmGetBy.mock.inspectFuncGetBy != nil {
		mmGetBy.mock.t.Fatalf("Inspect function is already set for OrderRepositoryMock.GetBy")
	}

	mmGetBy.mock.inspectFuncGetBy = f

	return mmGetBy
}

// Return sets up results that will be returned by Repository.GetBy
func (mmGetBy *mOrderRepositoryMockGetBy) Return(opa1 []*order.Order, err error) *OrderRepositoryMock {
	if mmGetBy.mock.funcGetBy != nil {
		mmGetBy.mock.t.Fatalf("OrderRepositoryMock.GetBy mock is already set by Set")
	}

	if mmGetBy.defaultExpectation == nil {
		mmGetBy.defaultExpectation = &OrderRepositoryMockGetByExpectation{mock: mmGetBy.mock}
	}
	mmGetBy.defaultExpectation.results = &OrderRepositoryMockGetByResults{opa1, err}
	mmGetBy.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetBy.mock
}

// Set uses given function f to mock the Repository.GetBy method
func (mmGetBy *mOrderRepositoryMockGetBy) Set(f func(ctx context.Context, fp1 *order.Filter) (opa1 []*order.Order, err error)) *OrderRepositoryMock {
	if mmGetBy.defaultExpectation != nil {
		mmGetBy.mock.t.Fatalf("Default expectation is already set for the Repository.GetBy method")
	}

	if len(mmGetBy.expectations) > 0 {
		mmGetBy.mock.t.Fatalf("Some expectations are already set for the Repository.GetBy method")
	}

	mmGetBy.mock.funcGetBy = f
	mmGetBy.mock.funcGetByOrigin = minimock.CallerInfo(1)
	return mmGetBy.mock
}

// When sets expectation for the Repository.GetBy which will trigger the result defined by the following
// Then helper
func (mmGetBy *mOrderRepositoryMockGetBy) When(ctx context.Context, fp1 *order.Filter) *OrderRepositoryMockGetByExpectation {
	if mmGetBy.mock.funcGetBy != nil {
		mmGetBy.mock.t.Fatalf("OrderRepositoryMock.GetBy mock is already set by Set")
	}

	expectation := &OrderRepositoryMockGetByExpectation{
		mock:               mmGetBy.mock,
		params:             &OrderRepositoryMockGetByParams{ctx, fp1},
		expectationOrigins: OrderRepositoryMockGetByExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetBy.expectations = append(mmGetBy.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetBy return parameters for the expectation previously defined by the When method
func (e *OrderRepositoryMockGetByExpectation) Then(opa1 []*order.Order, err error) *OrderRepositoryMock {
	e.results = &OrderRepositoryMockGetByResults{opa1, err}
	return e.mock
}

// Times sets number of times Repository.GetBy should be invoked
func (mmGetBy *mOrderRepositoryMockGetBy) Times(n uint64) *mOrderRepositoryMockGetBy {
	if n == 0 {
		mmGetBy.mock.t.Fatalf("Times of OrderRepositoryMock.GetBy mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetBy.expectedInvocations, n)
	mmGetBy.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetBy
}

func (mmGetBy *mOrderRepositoryMockGetBy) invocationsDone() bool {
	if len(mmGetBy.expectations) == 0 && mmGetBy.defaultExpectation == nil && mmGetBy.mock.funcGetBy == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetBy.mock.afterGetByCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetBy.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetBy implements mm_order.Repository
func (mmGetBy *OrderRepositoryMock) GetBy(ctx context.Context, fp1 *order.Filter) (opa1 []*order.Order, err error) {
	mm_atomic.AddUint64(&mmGetBy.beforeGetByCounter, 1)
	defer mm_atomic.AddUint64(&mmGetBy.afterGetByCounter, 1)

	mmGetBy.t.Helper()

	if mmGetBy.inspectFuncGetBy != nil {
		mmGetBy.inspectFuncGetBy(ctx, fp1)
	}

	mm_params := OrderRepositoryMockGetByParams{ctx, fp1}

	// Record call args
	mmGetBy.GetByMock.mutex.Lock()
	mmGetBy.GetByMock.callArgs = append(mmGetBy.GetByMock.callArgs, &mm_params)
	mmGetBy.GetByMock.mutex.Unlock()

	for _, e := range mmGetBy.GetByMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.opa1, e.results.err
		}
	}

	if mmGetBy.GetByMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetBy.GetByMock.defaultExpectation.Counter, 1)
		mm_want := mmGetBy.GetByMock.defaultExpectation.params
		mm_want_ptrs := mmGetBy.GetByMock.defaultExpectation.paramPtrs

		mm_got := OrderRepositoryMockGetByParams{ctx, fp1}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetBy.t.Errorf("OrderRepositoryMock.GetBy got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetBy.GetByMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.fp1 != nil && !minimock.Equal(*mm_want_ptrs.fp1, mm_got.fp1) {
				mmGetBy.t.Errorf("OrderRepositoryMock.GetBy got unexpected parameter fp1, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetBy.GetByMock.defaultExpectation.expectationOrigins.originFp1, *mm_want_ptrs.fp1, mm_got.fp1, minimock.Diff(*mm_want_ptrs.fp1, mm_got.fp1))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetBy.t.Errorf("OrderRepositoryMock.GetBy got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetBy.GetByMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetBy.GetByMock.defaultExpectation.results
		if mm_results == nil {
			mmGetBy.t.Fatal("No results are set for the OrderRepositoryMock.GetBy")
		}
		return (*mm_results).opa1, (*mm_results).err
	}
	if mmGetBy.funcGetBy != nil {
		return mmGetBy.funcGetBy(ctx, fp1)
	}
	mmGetBy.t.Fatalf("Unexpected call to OrderRepositoryMock.GetBy. %v %v", ctx, fp1)
	return
}

// GetByAfterCounter returns a count of finished OrderRepositoryMock.GetBy invocations
func (mmGetBy *OrderRepositoryMock) GetByAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetBy.afterGetByCounter)
}

// GetByBeforeCounter returns a count of OrderRepositoryMock.GetBy invocations
func (mmGetBy *OrderRepositoryMock) GetByBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetBy.beforeGetByCounter)
}

// Calls returns a list of arguments used in each call to OrderRepositoryMock.GetBy.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetBy *mOrderRepositoryMockGetBy) Calls() []*OrderRepositoryMockGetByParams {
	mmGetBy.mutex.RLock()

	argCopy := make([]*OrderRepositoryMockGetByParams, len(mmGetBy.callArgs))
	copy(argCopy, mmGetBy.callArgs)

	mmGetBy.mutex.RUnlock()

	return argCopy
}

// MinimockGetByDone returns true if the count of the GetBy invocations corresponds
// the number of defined expectations
func (m *OrderRepositoryMock) MinimockGetByDone() bool {
	if m.GetByMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetByMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetByMock.invocationsDone()
}

// MinimockGetByInspect logs each unmet expectation
func (m *OrderRepositoryMock) MinimockGetByInspect() {
	for _, e := range m.GetByMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OrderRepositoryMock.GetBy at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetByCounter := mm_atomic.LoadUint64(&m.afterGetByCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetByMock.defaultExpectation != nil && afterGetByCounter < 1 {
		if m.GetByMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to OrderRepositoryMock.GetBy at\n%s", m.GetByMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to OrderRepositoryMock.GetBy at\n%s with params: %#v", m.GetByMock.defaultExpectation.expectationOrigins.origin, *m.GetByMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetBy != nil && afterGetByCounter < 1 {
		m.t.Errorf("Expected call to OrderRepositoryMock.GetBy at\n%s", m.funcGetByOrigin)
	}

	if !m.GetByMock.invocationsDone() && afterGetByCounter > 0 {
		m.t.Errorf("Expected %d calls to OrderRepositoryMock.GetBy at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetByMock.expectedInvocations), m.GetByMock.expectedInvocationsOrigin, afterGetByCounter)
	}
}

type mOrderRepositoryMockGetByPaginated struct {
	optional           bool
	mock               *OrderRepositoryMock
	defaultExpectation *OrderRepositoryMockGetByPaginatedExpectation
	expectations       []*OrderRepositoryMockGetByPaginatedExpectation

	callArgs []*OrderRepositoryMockGetByPaginatedParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// OrderRepositoryMockGetByPaginatedExpectation specifies expectation struct of the Repository.GetByPaginated
type OrderRepositoryMockGetByPaginatedExpectation struct {
	mock               *OrderRepositoryMock
	params             *OrderRepositoryMockGetByPaginatedParams
	paramPtrs          *OrderRepositoryMockGetByPaginatedParamPtrs
	expectationOrigins OrderRepositoryMockGetByPaginatedExpectationOrigins
	results            *OrderRepositoryMockGetByPaginatedResults
	returnOrigin       string
	Counter            uint64
}

// OrderRepositoryMockGetByPaginatedParams contains parameters of the Repository.GetByPaginated
type OrderRepositoryMockGetByPaginatedParams struct {
	ctx    context.Context
	filter *order.Filter
	offset uint
	limit  int
}

// OrderRepositoryMockGetByPaginatedParamPtrs contains pointers to parameters of the Repository.GetByPaginated
type OrderRepositoryMockGetByPaginatedParamPtrs struct {
	ctx    *context.Context
	filter **order.Filter
	offset *uint
	limit  *int
}

// OrderRepositoryMockGetByPaginatedResults contains results of the Repository.GetByPaginated
type OrderRepositoryMockGetByPaginatedResults struct {
	opa1 []*order.Order
	err  error
}

// OrderRepositoryMockGetByPaginatedOrigins contains origins of expectations of the Repository.GetByPaginated
type OrderRepositoryMockGetByPaginatedExpectationOrigins struct {
	origin       string
	originCtx    string
	originFilter string
	originOffset string
	originLimit  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetByPaginated *mOrderRepositoryMockGetByPaginated) Optional() *mOrderRepositoryMockGetByPaginated {
	mmGetByPaginated.optional = true
	return mmGetByPaginated
}

// Expect sets up expected params for Repository.GetByPaginated
func (mmGetByPaginated *mOrderRepositoryMockGetByPaginated) Expect(ctx context.Context, filter *order.Filter, offset uint, limit int) *mOrderRepositoryMockGetByPaginated {
	if mmGetByPaginated.mock.funcGetByPaginated != nil {
		mmGetByPaginated.mock.t.Fatalf("OrderRepositoryMock.GetByPaginated mock is already set by Set")
	}

	if mmGetByPaginated.defaultExpectation == nil {
		mmGetByPaginated.defaultExpectation = &OrderRepositoryMockGetByPaginatedExpectation{}
	}

	if mmGetByPaginated.defaultExpectation.paramPtrs != nil {
		mmGetByPaginated.mock.t.Fatalf("OrderRepositoryMock.GetByPaginated mock is already set by ExpectParams functions")
	}

	mmGetByPaginated.defaultExpectation.params = &OrderRepositoryMockGetByPaginatedParams{ctx, filter, offset, limit}
	mmGetByPaginated.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetByPaginated.expectations {
		if minimock.Equal(e.params, mmGetByPaginated.defaultExpectation.params) {
			mmGetByPaginated.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetByPaginated.defaultExpectation.params)
		}
	}

	return mmGetByPaginated
}

// ExpectCtxParam1 sets up expected param ctx for Repository.GetByPaginated
func (mmGetByPaginated *mOrderRepositoryMockGetByPaginated) ExpectCtxParam1(ctx context.Context) *mOrderRepositoryMockGetByPaginated {
	if mmGetByPaginated.mock.funcGetByPaginated != nil {
		mmGetByPaginated.mock.t.Fatalf("OrderRepositoryMock.GetByPaginated mock is already set by Set")
	}

	if mmGetByPaginated.defaultExpectation == nil {
		mmGetByPaginated.defaultExpectation = &OrderRepositoryMockGetByPaginatedExpectation{}
	}

	if mmGetByPaginated.defaultExpectation.params != nil {
		mmGetByPaginated.mock.t.Fatalf("OrderRepositoryMock.GetByPaginated mock is already set by Expect")
	}

	if mmGetByPaginated.defaultExpectation.paramPtrs == nil {
		mmGetByPaginated.defaultExpectation.paramPtrs = &OrderRepositoryMockGetByPaginatedParamPtrs{}
	}
	mmGetByPaginated.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetByPaginated.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetByPaginated
}

// ExpectFilterParam2 sets up expected param filter for Repository.GetByPaginated
func (mmGetByPaginated *mOrderRepositoryMockGetByPaginated) ExpectFilterParam2(filter *order.Filter) *mOrderRepositoryMockGetByPaginated {
	if mmGetByPaginated.mock.funcGetByPaginated != nil {
		mmGetByPaginated.mock.t.Fatalf("OrderRepositoryMock.GetByPaginated mock is already set by Set")
	}

	if mmGetByPaginated.defaultExpectation == nil {
		mmGetByPaginated.defaultExpectation = &OrderRepositoryMockGetByPaginatedExpectation{}
	}

	if mmGetByPaginated.defaultExpectation.params != nil {
		mmGetByPaginated.mock.t.Fatalf("OrderRepositoryMock.GetByPaginated mock is already set by Expect")
	}

	if mmGetByPaginated.defaultExpectation.paramPtrs == nil {
		mmGetByPaginated.defaultExpectation.paramPtrs = &OrderRepositoryMockGetByPaginatedParamPtrs{}
	}
	mmGetByPaginated.defaultExpectation.paramPtrs.filter = &filter
	mmGetByPaginated.defaultExpectation.expectationOrigins.originFilter = minimock.CallerInfo(1)

	return mmGetByPaginated
}

// ExpectOffsetParam3 sets up expected param offset for Repository.GetByPaginated
func (mmGetByPaginated *mOrderRepositoryMockGetByPaginated) ExpectOffsetParam3(offset uint) *mOrderRepositoryMockGetByPaginated {
	if mmGetByPaginated.mock.funcGetByPaginated != nil {
		mmGetByPaginated.mock.t.Fatalf("OrderRepositoryMock.GetByPaginated mock is already set by Set")
	}

	if mmGetByPaginated.defaultExpectation == nil {
		mmGetByPaginated.defaultExpectation = &OrderRepositoryMockGetByPaginatedExpectation{}
	}

	if mmGetByPaginated.defaultExpectation.params != nil {
		mmGetByPaginated.mock.t.Fatalf("OrderRepositoryMock.GetByPaginated mock is already set by Expect")
	}

	if mmGetByPaginated.defaultExpectation.paramPtrs == nil {
		mmGetByPaginated.defaultExpectation.paramPtrs = &OrderRepositoryMockGetByPaginatedParamPtrs{}
	}
	mmGetByPaginated.defaultExpectation.paramPtrs.offset = &offset
	mmGetByPaginated.defaultExpectation.expectationOrigins.originOffset = minimock.CallerInfo(1)

	return mmGetByPaginated
}

// ExpectLimitParam4 sets up expected param limit for Repository.GetByPaginated
func (mmGetByPaginated *mOrderRepositoryMockGetByPaginated) ExpectLimitParam4(limit int) *mOrderRepositoryMockGetByPaginated {
	if mmGetByPaginated.mock.funcGetByPaginated != nil {
		mmGetByPaginated.mock.t.Fatalf("OrderRepositoryMock.GetByPaginated mock is already set by Set")
	}

	if mmGetByPaginated.defaultExpectation == nil {
		mmGetByPaginated.defaultExpectation = &OrderRepositoryMockGetByPaginatedExpectation{}
	}

	if mmGetByPaginated.defaultExpectation.params != nil {
		mmGetByPaginated.mock.t.Fatalf("OrderRepositoryMock.GetByPaginated mock is already set by Expect")
	}

	if mmGetByPaginated.defaultExpectation.paramPtrs == nil {
		mmGetByPaginated.defaultExpectation.paramPtrs = &OrderRepositoryMockGetByPaginatedParamPtrs{}
	}
	mmGetByPaginated.defaultExpectation.paramPtrs.limit = &limit
	mmGetByPaginated.defaultExpectation.expectationOrigins.originLimit = minimock.CallerInfo(1)

	return mmGetByPaginated
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetByPaginated
func (mmGetByPaginated *mOrderRepositoryMockGetByPaginated) Inspect(f func(ctx context.Context, filter *order.Filter, offset uint, limit int)) *mOrderRepositoryMockGetByPaginated {
	if mmGetByPaginated.mock.inspectFuncGetByPaginated != nil {
		mmGetByPaginated.mock.t.Fatalf("Inspect function is already set for OrderRepositoryMock.GetByPaginated")
	}

	mmGetByPaginated.mock.inspectFuncGetByPaginated = f

	return mmGetByPaginated
}

// Return sets up results that will be returned by Repository.GetByPaginated
func (mmGetByPaginated *mOrderRepositoryMockGetByPaginated) Return(opa1 []*order.Order, err error) *OrderRepositoryMock {
	if mmGetByPaginated.mock.funcGetByPaginated != nil {
		mmGetByPaginated.mock.t.Fatalf("OrderRepositoryMock.GetByPaginated mock is already set by Set")
	}

	if mmGetByPaginated.defaultExpectation == nil {
		mmGetByPaginated.defaultExpectation = &OrderRepositoryMockGetByPaginatedExpectation{mock: mmGetByPaginated.mock}
	}
	mmGetByPaginated.defaultExpectation.results = &OrderRepositoryMockGetByPaginatedResults{opa1, err}
	mmGetByPaginated.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetByPaginated.mock
}

// Set uses given function f to mock the Repository.GetByPaginated method
func (mmGetByPaginated *mOrderRepositoryMockGetByPaginated) Set(f func(ctx context.Context, filter *order.Filter, offset uint, limit int) (opa1 []*order.Order, err error)) *OrderRepositoryMock {
	if mmGetByPaginated.defaultExpectation != nil {
		mmGetByPaginated.mock.t.Fatalf("Default expectation is already set for the Repository.GetByPaginated method")
	}

	if len(mmGetByPaginated.expectations) > 0 {
		mmGetByPaginated.mock.t.Fatalf("Some expectations are already set for the Repository.GetByPaginated method")
	}

	mmGetByPaginated.mock.funcGetByPaginated = f
	mmGetByPaginated.mock.funcGetByPaginatedOrigin = minimock.CallerInfo(1)
	return mmGetByPaginated.mock
}

// When sets expectation for the Repository.GetByPaginated which will trigger the result defined by the following
// Then helper
func (mmGetByPaginated *mOrderRepositoryMockGetByPaginated) When(ctx context.Context, filter *order.Filter, offset uint, limit int) *OrderRepositoryMockGetByPaginatedExpectation {
	if mmGetByPaginated.mock.funcGetByPaginated != nil {
		mmGetByPaginated.mock.t.Fatalf("OrderRepositoryMock.GetByPaginated mock is already set by Set")
	}

	expectation := &OrderRepositoryMockGetByPaginatedExpectation{
		mock:               mmGetByPaginated.mock,
		params:             &OrderRepositoryMockGetByPaginatedParams{ctx, filter, offset, limit},
		expectationOrigins: OrderRepositoryMockGetByPaginatedExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetByPaginated.expectations = append(mmGetByPaginated.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetByPaginated return parameters for the expectation previously defined by the When method
func (e *OrderRepositoryMockGetByPaginatedExpectation) Then(opa1 []*order.Order, err error) *OrderRepositoryMock {
	e.results = &OrderRepositoryMockGetByPaginatedResults{opa1, err}
	return e.mock
}

// Times sets number of times Repository.GetByPaginated should be invoked
func (mmGetByPaginated *mOrderRepositoryMockGetByPaginated) Times(n uint64) *mOrderRepositoryMockGetByPaginated {
	if n == 0 {
		mmGetByPaginated.mock.t.Fatalf("Times of OrderRepositoryMock.GetByPaginated mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetByPaginated.expectedInvocations, n)
	mmGetByPaginated.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetByPaginated
}

func (mmGetByPaginated *mOrderRepositoryMockGetByPaginated) invocationsDone() bool {
	if len(mmGetByPaginated.expectations) == 0 && mmGetByPaginated.defaultExpectation == nil && mmGetByPaginated.mock.funcGetByPaginated == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetByPaginated.mock.afterGetByPaginatedCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetByPaginated.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetByPaginated implements mm_order.Repository
func (mmGetByPaginated *OrderRepositoryMock) GetByPaginated(ctx context.Context, filter *order.Filter, offset uint, limit int) (opa1 []*order.Order, err error) {
	mm_atomic.AddUint64(&mmGetByPaginated.beforeGetByPaginatedCounter, 1)
	defer mm_atomic.AddUint64(&mmGetByPaginated.afterGetByPaginatedCounter, 1)

	mmGetByPaginated.t.Helper()

	if mmGetByPaginated.inspectFuncGetByPaginated != nil {
		mmGetByPaginated.inspectFuncGetByPaginated(ctx, filter, offset, limit)
	}

	mm_params := OrderRepositoryMockGetByPaginatedParams{ctx, filter, offset, limit}

	// Record call args
	mmGetByPaginated.GetByPaginatedMock.mutex.Lock()
	mmGetByPaginated.GetByPaginatedMock.callArgs = append(mmGetByPaginated.GetByPaginatedMock.callArgs, &mm_params)
	mmGetByPaginated.GetByPaginatedMock.mutex.Unlock()

	for _, e := range mmGetByPaginated.GetByPaginatedMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.opa1, e.results.err
		}
	}

	if mmGetByPaginated.GetByPaginatedMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetByPaginated.GetByPaginatedMock.defaultExpectation.Counter, 1)
		mm_want := mmGetByPaginated.GetByPaginatedMock.defaultExpectation.params
		mm_want_ptrs := mmGetByPaginated.GetByPaginatedMock.defaultExpectation.paramPtrs

		mm_got := OrderRepositoryMockGetByPaginatedParams{ctx, filter, offset, limit}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetByPaginated.t.Errorf("OrderRepositoryMock.GetByPaginated got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetByPaginated.GetByPaginatedMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.filter != nil && !minimock.Equal(*mm_want_ptrs.filter, mm_got.filter) {
				mmGetByPaginated.t.Errorf("OrderRepositoryMock.GetByPaginated got unexpected parameter filter, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetByPaginated.GetByPaginatedMock.defaultExpectation.expectationOrigins.originFilter, *mm_want_ptrs.filter, mm_got.filter, minimock.Diff(*mm_want_ptrs.filter, mm_got.filter))
			}

			if mm_want_ptrs.offset != nil && !minimock.Equal(*mm_want_ptrs.offset, mm_got.offset) {
				mmGetByPaginated.t.Errorf("OrderRepositoryMock.GetByPaginated got unexpected parameter offset, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetByPaginated.GetByPaginatedMock.defaultExpectation.expectationOrigins.originOffset, *mm_want_ptrs.offset, mm_got.offset, minimock.Diff(*mm_want_ptrs.offset, mm_got.offset))
			}

			if mm_want_ptrs.limit != nil && !minimock.Equal(*mm_want_ptrs.limit, mm_got.limit) {
				mmGetByPaginated.t.Errorf("OrderRepositoryMock.GetByPaginated got unexpected parameter limit, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetByPaginated.GetByPaginatedMock.defaultExpectation.expectationOrigins.originLimit, *mm_want_ptrs.limit, mm_got.limit, minimock.Diff(*mm_want_ptrs.limit, mm_got.limit))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetByPaginated.t.Errorf("OrderRepositoryMock.GetByPaginated got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetByPaginated.GetByPaginatedMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetByPaginated.GetByPaginatedMock.defaultExpectation.results
		if mm_results == nil {
			mmGetByPaginated.t.Fatal("No results are set for the OrderRepositoryMock.GetByPaginated")
		}
		return (*mm_results).opa1, (*mm_results).err
	}
	if mmGetByPaginated.funcGetByPaginated != nil {
		return mmGetByPaginated.funcGetByPaginated(ctx, filter, offset, limit)
	}
	mmGetByPaginated.t.Fatalf("Unexpected call to OrderRepositoryMock.GetByPaginated. %v %v %v %v", ctx, filter, offset, limit)
	return
}

// GetByPaginatedAfterCounter returns a count of finished OrderRepositoryMock.GetByPaginated invocations
func (mmGetByPaginated *OrderRepositoryMock) GetByPaginatedAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetByPaginated.afterGetByPaginatedCounter)
}

// GetByPaginatedBeforeCounter returns a count of OrderRepositoryMock.GetByPaginated invocations
func (mmGetByPaginated *OrderRepositoryMock) GetByPaginatedBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetByPaginated.beforeGetByPaginatedCounter)
}

// Calls returns a list of arguments used in each call to OrderRepositoryMock.GetByPaginated.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetByPaginated *mOrderRepositoryMockGetByPaginated) Calls() []*OrderRepositoryMockGetByPaginatedParams {
	mmGetByPaginated.mutex.RLock()

	argCopy := make([]*OrderRepositoryMockGetByPaginatedParams, len(mmGetByPaginated.callArgs))
	copy(argCopy, mmGetByPaginated.callArgs)

	mmGetByPaginated.mutex.RUnlock()

	return argCopy
}

// MinimockGetByPaginatedDone returns true if the count of the GetByPaginated invocations corresponds
// the number of defined expectations
func (m *OrderRepositoryMock) MinimockGetByPaginatedDone() bool {
	if m.GetByPaginatedMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetByPaginatedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetByPaginatedMock.invocationsDone()
}

// MinimockGetByPaginatedInspect logs each unmet expectation
func (m *OrderRepositoryMock) MinimockGetByPaginatedInspect() {
	for _, e := range m.GetByPaginatedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OrderRepositoryMock.GetByPaginated at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetByPaginatedCounter := mm_atomic.LoadUint64(&m.afterGetByPaginatedCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetByPaginatedMock.defaultExpectation != nil && afterGetByPaginatedCounter < 1 {
		if m.GetByPaginatedMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to OrderRepositoryMock.GetByPaginated at\n%s", m.GetByPaginatedMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to OrderRepositoryMock.GetByPaginated at\n%s with params: %#v", m.GetByPaginatedMock.defaultExpectation.expectationOrigins.origin, *m.GetByPaginatedMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetByPaginated != nil && afterGetByPaginatedCounter < 1 {
		m.t.Errorf("Expected call to OrderRepositoryMock.GetByPaginated at\n%s", m.funcGetByPaginatedOrigin)
	}

	if !m.GetByPaginatedMock.invocationsDone() && afterGetByPaginatedCounter > 0 {
		m.t.Errorf("Expected %d calls to OrderRepositoryMock.GetByPaginated at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetByPaginatedMock.expectedInvocations), m.GetByPaginatedMock.expectedInvocationsOrigin, afterGetByPaginatedCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *OrderRepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockAddOrUpdateInspect()

			m.MinimockAddOrUpdateListInspect()

			m.MinimockDeleteInspect()

			m.MinimockDeleteByInspect()

			m.MinimockGetInspect()

			m.MinimockGetByInspect()

			m.MinimockGetByPaginatedInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *OrderRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *OrderRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddOrUpdateDone() &&
		m.MinimockAddOrUpdateListDone() &&
		m.MinimockDeleteDone() &&
		m.MinimockDeleteByDone() &&
		m.MinimockGetDone() &&
		m.MinimockGetByDone() &&
		m.MinimockGetByPaginatedDone()
}
